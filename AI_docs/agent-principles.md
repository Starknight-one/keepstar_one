# Agent Programming Principles

Общие принципы построения агентного слоя.

## Core Principles

### 1. One Prompt = One Agent = One Task

Каждый агент делает одну вещь хорошо. Нет универсальных агентов-мастеров на все руки.

### 2. Reduce & Delegate

Режь большие задачи на мелкие. Делегируй исполнение частей другим агентам.

> **Большие штуки — это всегда группа хорошо работающих небольших.**

```
Big Task → [slice] → Task A, Task B, Task C
                         ↓       ↓       ↓
                      Agent A  Agent B  Agent C
```

### 3. Code + Agents > Just Agents

Архитектурный принцип разделения:

| Тип задачи | Исполнитель |
|------------|-------------|
| Стохастическая (понимание, генерация, решения) | Agent (LLM) |
| Детерминированная (валидация, трансформация, I/O) | Code |

Всё что МОЖЕТ быть сделано кодом — ДОЛЖНО быть сделано кодом.

### 4. Domain Focus > Universal Layer

Агентный слой должен быть заточен под конкретную кодовую базу, а не универсальный.

**Почему универсальность не работает:**
- Агент не знает специфику системы → поверхностные решения
- Нет знания о паттернах проекта → изобретает велосипеды
- Нет понимания связей между компонентами → ломает интеграции

**Что нужно:**
- **Domain Knowledge** — структурированное описание системы (модули, паттерны, связи)
- **Specialized Commands** — команды заточенные под типы задач в этой системе
- **Self-Refresh** — knowledge обновляется после каждого изменения кодовой базы

> Агентный слой должен знать систему. Не догадываться — знать.

---

## 12 Leverage Points

### Core 4

| Point | Description |
|-------|-------------|
| **Context** | Что агент знает о задаче и системе |
| **Model** | Какая модель (haiku/sonnet/opus) |
| **Prompt** | Инструкции что делать |
| **Tools** | Инструменты для исполнения |

### 8 Through Agent

| Point | Зачем |
|-------|-------|
| **Architecture** | Структура решает. Правильная архитектура упрощает всё остальное |
| **Tests** | Проверка = уверенность. Агент может проверить свою работу |
| **Types/Contracts** | Код = направленный поток информации. Типы показывают агентам КУДА и КАК течёт информация |
| **Documentation** | Агент должен понимать систему чтобы работать с ней |
| **Standardized Output** | Видно что происходит. Агент понимает статус |
| **Automation** | Автоматизация групп агентов через код, не вручную |
| **Templating Work** | Если что-то повторяется — автоматизируй, не делай вручную |
| **Plans** | Чёткое понимание что делать. Можно валидировать до исполнения |

---

## PITER Framework

Фреймворк для проектирования агентных задач:

| Letter | Component | Question |
|--------|-----------|----------|
| **P** | Prompt | Что агент должен сделать? |
| **I** | Input | Какие данные на входе? |
| **T** | Trigger | Что заставит агента действовать, когда он начнёт работу и что будет на входе |
| **E** | Environment | В каком контексте работает? (файлы, tools, доступы) |
| **R** | Review | Как валидировать результат? |

---

## Error Philosophy

> Ошибки агента = недоработка агентного слоя

**Принцип**: Если задача была верно составлена, но агент не справился — чини агентный слой.

```
Task failed via agents
    ↓
Was task correctly specified?
    ├── No  → Fix task specification
    └── Yes → Fix agent layer (leverage points)
```

Не babysit агентов. Инвестируй в улучшение слоя.

---

## KPIs

Метрики качества агентного слоя:

| KPI | Что измеряет | Стремится к |
|-----|--------------|-------------|
| **Size** | Операции, завершённые агентами | → ∞ |
| **Attempts** | Промптов до завершения задачи | → 1 |
| **Streak** | Успешных завершений подряд с 1 промпта | → ∞ |
| **Presence** | Вмешательств человека в процессе | → 0 |

> Presence > 0 = сигнал что агентный слой нужно улучшить.

---

## Priority

Приоритет — развитие агентного слоя, даже если это некомфортно. Слой должен ускорять разработку, а не требовать постоянного присмотра.

**Цель**: Максимизировать Size и Streak. Минимизировать Attempts и Presence.
