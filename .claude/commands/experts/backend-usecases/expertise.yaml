# Backend Usecases Expertise
# Business logic - 1 file = 1 use case

overview:
  layer: "usecases"
  path: "project/backend/internal/usecases/"
  imports: "domain/, ports/, prompts/, tools/, presets/, logger/"
  contains: "Business logic orchestration"

pattern:
  - "Struct with port dependencies"
  - "NewXxxUseCase() constructor"
  - "Execute(ctx, req) method"
  - "Graceful degradation if DB not configured"

usecases:
  chat:
    send_message:
      file: "chat_send_message.go"
      struct: "SendMessageUseCase"
      purpose: "Send message to LLM, save to DB, track events"
      methods:
        - "Execute(ctx, req) (*SendMessageResponse, error)"
        - "WithSessionTTL(duration) *SendMessageUseCase"
      features:
        - "Session management with sliding TTL (5 min via domain.SessionTTL)"
        - "Message persistence to PostgreSQL"
        - "Event tracking (chat_opened, message_sent, message_received)"

  catalog:
    list_products:
      file: "catalog_list_products.go"
      struct: "ListProductsUseCase"
      purpose: "List products for tenant with filtering"
      methods: ["Execute(ctx, req) (*ListProductsResponse, error)"]

    get_product:
      file: "catalog_get_product.go"
      struct: "GetProductUseCase"
      purpose: "Get single product with master data merging"
      methods: ["Execute(ctx, req) (*Product, error)"]

  pipeline:
    agent1_execute:
      file: "agent1_execute.go"
      struct: "Agent1ExecuteUseCase"
      purpose: "Agent 1 Tool Caller - query → tool call → state"
      request: "{ SessionID, Query, TenantSlug, TurnID }"
      response: "{ Usage, LatencyMs, LLMCallMs, ToolExecuteMs, ToolName, ToolInput, ToolResult, ToolMetadata, ProductsFound, StopReason, SystemPrompt, SystemPromptChars, MessageCount, ToolDefCount }"
      flow:
        - "Get or create session state"
        - "Build messages from ConversationHistory + new query"
        - "Call LLM with ChatWithToolsCached (cache tools, system, conversation)"
        - "Execute tool call via Registry"
        - "Re-read state after tool zone-write to get productsFound"
        - "AppendConversation zone-write (user+assistant:tool_use+user:tool_result messages)"
      tools: "getAgent1Tools() filters search_* and _internal_* tools from registry"
      exported: "GetToolDefs() — exported wrapper of getAgent1Tools() for testing"

    agent2_execute:
      file: "agent2_execute.go"
      struct: "Agent2ExecuteUseCase"
      purpose: "Agent 2 Preset Selector - meta → LLM tool call → render tool → formation"
      request: "{ SessionID, TurnID, UserQuery }"
      response: "{ Template, Formation, Usage, LatencyMs, ToolCalled, ToolName, LLMCallMs, PromptSent, RawResponse, TemplateJSON, MetaCount, MetaFields }"
      flow:
        - "Get current state (must exist after Agent 1)"
        - "Return empty if no products/services"
        - "Look up data delta for current TurnID (for Agent2 context)"
        - "Build prompt with meta, view state, user query, and data delta (BuildAgent2ToolPrompt)"
        - "Call LLM with ChatWithToolsCached (cache tools, system)"
        - "Execute render tool call via Registry (tool writes formation to state)"
        - "Get formation from state.Template['formation']"
      tools: "getAgent2Tools() filters render_* and freestyle tools from registry"

    pipeline_execute:
      file: "pipeline_execute.go"
      struct: "PipelineExecuteUseCase"
      purpose: "Orchestrator: Agent 1 → Agent 2 → Formation"
      request: "{ SessionID, Query, TenantSlug, TurnID }"
      response: "{ Formation, Agent1Ms, Agent2Ms, TotalMs, Agent1Usage, Agent2Usage, Agent1LLMMs, Agent1ToolMs, ToolCalled, ToolInput, ToolResult, ProductsFound, Agent2LLMMs, Agent2Prompt, Agent2RawResp, TemplateJSON, MetaCount, MetaFields }"
      flow:
        - "Ensure session exists (CachePort) for FK constraint"
        - "Generate TurnID for delta grouping"
        - "Step 1: Agent 1 (Tool Caller)"
        - "Step 2: Agent 2 (Template Builder via render tool)"
        - "Step 3: Get formation from state (built by render tool, fallback to ApplyTemplate)"

    template_apply:
      file: "template_apply.go"
      purpose: "Apply FormationTemplate to products"
      functions:
        - "ApplyTemplate(template, products) (*FormationWithData, error)"
      field_mapping: ["id→ID", "name→Name", "price→Price", "images→Images[0]", "rating→Rating", "brand→Brand"]

  state:
    state_reconstruct:
      file: "state_reconstruct.go"
      struct: "ReconstructStateUseCase"
      purpose: "Reconstruct session state at any given step by replaying deltas"
      request: "{ SessionID, ToStep }"
      response: "{ State, Deltas, StepNow, DeltaCount }"
      flow:
        - "Get deltas until target step"
        - "Build base state (step 0)"
        - "Apply deltas sequentially"
        - "Return reconstructed state"

    state_rollback:
      file: "state_rollback.go"
      struct: "RollbackUseCase"
      purpose: "Roll back state to a previous step"
      request: "{ SessionID, ToStep, Source, ActorID }"
      response: "{ State, RolledBack, FromStep, ToStep, RollbackDelta }"
      flow:
        - "Get current state"
        - "Validate rollback target"
        - "Reconstruct state at target step"
        - "Create rollback delta (preserves history)"
        - "Update current state"

  navigation:
    navigation_expand:
      file: "navigation_expand.go"
      struct: "ExpandUseCase"
      purpose: "Expand widget to detail view (drill-down)"
      request: "{ SessionID, EntityType, EntityID, TurnID }"
      response: "{ Success, Formation, ViewMode, Focused, StackSize }"
      flow:
        - "Get current state"
        - "Find entity and get detail preset"
        - "Push current view to ViewStack (PushView)"
        - "Build detail formation from preset"
        - "Zone-write UpdateView (view zone — detail mode)"
        - "Zone-write UpdateTemplate (template zone — formation)"

    navigation_back:
      file: "navigation_back.go"
      struct: "BackUseCase"
      purpose: "Navigate back from detail to previous view"
      request: "{ SessionID, TurnID }"
      response: "{ Success, Formation, ViewMode, Focused, StackSize, CanGoBack }"
      flow:
        - "Pop view from ViewStack (PopView)"
        - "Get current state"
        - "Rebuild formation from state data (rebuildFormationFromState)"
        - "Zone-write UpdateView (view zone — restore previous)"
        - "Zone-write UpdateTemplate (template zone — rebuilt formation)"

gotchas:
  - "Create session (CachePort) before creating state (StatePort)"
  - "Tools return 'ok'/'empty', not raw data"
  - "Agent1 stops after first tool call, doesn't see result"
  - "Agent2 receives meta, view state, user query, and data delta — never raw product data"
  - "Agent2 expects state to exist (run Agent1 first)"
  - "LLM may wrap JSON in markdown code blocks, use extractJSON()"
  - "Agent1 uses AppendConversation zone-write (not UpdateState blob) after each call"
  - "AddDelta auto-assigns step — no manual state.Step++ needed"
  - "Agent1 filters tools to search_* and _internal_* via getAgent1Tools()"
  - "Agent2 filters tools to render_* and freestyle via getAgent2Tools()"
  - "Pipeline generates TurnID (uuid) for delta grouping if not provided"
  - "Navigation uses zone-writes (UpdateView, UpdateTemplate) not blob UpdateState"

naming: "{domain}_{action}.go"
