# Backend Usecases Expertise
# Business logic - 1 file = 1 use case

overview:
  layer: "usecases"
  path: "project/backend/internal/usecases/"
  imports: "domain/, ports/, prompts/, tools/, presets/, logger/"
  contains: "Business logic orchestration"

pattern:
  - "Struct with port dependencies"
  - "NewXxxUseCase() constructor"
  - "Execute(ctx, req) method"
  - "Graceful degradation if DB not configured"

usecases:
  chat:
    send_message:
      file: "chat_send_message.go"
      struct: "SendMessageUseCase"
      purpose: "Send message to LLM, save to DB, track events"
      methods:
        - "Execute(ctx, req) (*SendMessageResponse, error)"
        - "WithSessionTTL(duration) *SendMessageUseCase"
      features:
        - "Session management with sliding TTL (5 min via domain.SessionTTL)"
        - "Message persistence to PostgreSQL"
        - "Event tracking (chat_opened, message_sent, message_received)"

  catalog:
    list_products:
      file: "catalog_list_products.go"
      struct: "ListProductsUseCase"
      purpose: "List products for tenant with filtering"
      methods: ["Execute(ctx, req) (*ListProductsResponse, error)"]

    get_product:
      file: "catalog_get_product.go"
      struct: "GetProductUseCase"
      purpose: "Get single product with master data merging"
      methods: ["Execute(ctx, req) (*Product, error)"]

  pipeline:
    agent1_execute:
      file: "agent1_execute.go"
      struct: "Agent1ExecuteUseCase"
      purpose: "Agent 1 Tool Caller - query → tool call → state"
      constructor_deps: ["LLMPort", "StatePort", "CatalogPort", "Registry", "Logger"]
      request: "{ SessionID, Query, TenantSlug, TurnID }"
      response: "{ Usage, LatencyMs, LLMCallMs, ToolExecuteMs, ToolName, ToolInput, ToolResult, ToolMetadata, ProductsFound, StopReason, SystemPrompt, SystemPromptChars, EnrichedQuery, MessageCount, ToolDefCount }"
      flow:
        - "Start 'agent1' span + set WithStage(ctx, 'agent1')"
        - "Get or create session state"
        - "Set tenant_slug in state aliases"
        - "Extract current RenderConfig from state formation (for context prompt)"
        - "Load pre-computed CatalogDigest for tenant (via CatalogPort.GetCatalogDigest)"
        - "Build enriched query via BuildAgent1ContextPrompt(meta, currentConfig, query, digest) — adds <catalog> + <state> blocks"
        - "Build messages from ConversationHistory + enriched query"
        - "Call LLM with ChatWithToolsCached (cache tools, system, conversation)"
        - "Execute tool call via Registry (span: 'agent1.tool')"
        - "Re-read state after tool zone-write to get productsFound"
        - "AppendConversation zone-write (span: 'agent1.state')"
      tools: "getAgent1Tools() filters catalog_* and _internal_* tools from registry"
      exported: "GetToolDefs() — exported wrapper of getAgent1Tools() for testing"
      test_file: "agent1_execute_test.go"

    agent2_execute:
      file: "agent2_execute.go"
      struct: "Agent2ExecuteUseCase"
      purpose: "Agent 2 Preset Selector - meta → LLM tool call → render tool → formation"
      request: "{ SessionID, TurnID, UserQuery }"
      response: "{ Template, Formation, Usage, LatencyMs, ToolCalled, ToolName, LLMCallMs, PromptSent, RawResponse, TemplateJSON, MetaCount, MetaFields }"
      flow:
        - "Start 'agent2' span + set WithStage(ctx, 'agent2')"
        - "Get current state (must exist after Agent 1)"
        - "Return empty if no products/services"
        - "Look up data delta for current TurnID (for Agent2 context)"
        - "Build prompt with meta, view state, user query, and data delta (BuildAgent2ToolPrompt)"
        - "Include recent user queries from ConversationHistory (last 4 user messages, skip tool_use/tool_result)"
        - "Call LLM with ChatWithToolsCached (cache tools, system, ToolChoice='any')"
        - "Execute render tool call via Registry (span: 'agent2.tool', tool writes formation to state)"
        - "Get formation from state.Template['formation']"
      tools: "getAgent2Tools() filters render_* and freestyle tools from registry"
      test_file: "agent2_execute_test.go"

    pipeline_execute:
      file: "pipeline_execute.go"
      struct: "PipelineExecuteUseCase"
      purpose: "Orchestrator: Agent 1 → Agent 2 → Formation"
      request: "{ SessionID, Query, TenantSlug, TurnID }"
      response: "{ Formation, Agent1Ms, Agent2Ms, TotalMs, Agent1Usage, Agent2Usage, Agent1LLMMs, Agent1ToolMs, ToolCalled, ToolInput, ToolResult, ProductsFound, Agent2LLMMs, Agent2Prompt, Agent2RawResp, TemplateJSON, MetaCount, MetaFields }"
      flow:
        - "Create SpanCollector + attach to context via WithSpanCollector"
        - "Start 'pipeline' span"
        - "Prepare PipelineTrace"
        - "Ensure session exists (CachePort) for FK constraint"
        - "Generate TurnID for delta grouping"
        - "Step 1: Agent 1 (Tool Caller)"
        - "Snapshot state after Agent1 (with turn deltas)"
        - "Step 2: Agent 2 (Template Builder via render tool)"
        - "Step 3: Get formation from state (built by render tool, fallback to ApplyTemplate)"
        - "End 'pipeline' span, attach trace.Spans = sc.Spans()"
        - "Record trace via TracePort"

    template_apply:
      file: "template_apply.go"
      purpose: "Apply FormationTemplate to products"
      functions:
        - "ApplyTemplate(template, products) (*FormationWithData, error)"
      field_mapping: ["id→ID", "name→Name", "price→Price", "images→Images[0]", "rating→Rating", "brand→Brand"]

  state:
    state_reconstruct:
      file: "state_reconstruct.go"
      struct: "ReconstructStateUseCase"
      purpose: "Reconstruct session state at any given step by replaying deltas"
      request: "{ SessionID, ToStep }"
      response: "{ State, Deltas, StepNow, DeltaCount }"
      flow:
        - "Get deltas until target step"
        - "Build base state (step 0)"
        - "Apply deltas sequentially"
        - "Return reconstructed state"

    state_rollback:
      file: "state_rollback.go"
      struct: "RollbackUseCase"
      purpose: "Roll back state to a previous step"
      request: "{ SessionID, ToStep, Source, ActorID }"
      response: "{ State, RolledBack, FromStep, ToStep, RollbackDelta }"
      flow:
        - "Get current state"
        - "Validate rollback target"
        - "Reconstruct state at target step"
        - "Create rollback delta (preserves history)"
        - "Update current state"

  navigation:
    navigation_expand:
      file: "navigation_expand.go"
      struct: "ExpandUseCase"
      purpose: "Expand widget to detail view (drill-down)"
      request: "{ SessionID, EntityType, EntityID, TurnID }"
      response: "{ Success, Formation, ViewMode, Focused, StackSize }"
      flow:
        - "Get current state"
        - "Find entity and get detail preset"
        - "Push current view to ViewStack (PushView)"
        - "Build detail formation from preset"
        - "Zone-write UpdateView (view zone — detail mode)"
        - "Zone-write UpdateTemplate (template zone — formation)"

    navigation_back:
      file: "navigation_back.go"
      struct: "BackUseCase"
      purpose: "Navigate back from detail to previous view"
      request: "{ SessionID, TurnID }"
      response: "{ Success, Formation, ViewMode, Focused, StackSize, CanGoBack }"
      flow:
        - "Pop view from ViewStack (PopView)"
        - "Get current state"
        - "Rebuild formation from state data (rebuildFormationFromState)"
        - "Zone-write UpdateView (view zone — restore previous)"
        - "Zone-write UpdateTemplate (template zone — rebuilt formation)"

test_files:
  - "agent1_execute_test.go - Agent1 execution tests"
  - "agent2_execute_test.go - Agent2 execution tests"
  - "cache_test.go - Cache/session tests"
  - "navigation_test.go - Navigation expand/back tests"
  - "state_rollback_test.go - State rollback tests"

gotchas:
  - "Create session (CachePort) before creating state (StatePort)"
  - "Tools return 'ok'/'empty', not raw data"
  - "Agent1 stops after first tool call, doesn't see result"
  - "Agent2 receives meta, view state, user query, and data delta — never raw product data"
  - "Agent2 expects state to exist (run Agent1 first)"
  - "Agent2 forces tool call via ToolChoice='any' in CacheConfig"
  - "Agent2 includes last 4 user messages from ConversationHistory (filters out tool_use/tool_result)"
  - "LLM may wrap JSON in markdown code blocks, use extractJSON()"
  - "Agent1 uses AppendConversation zone-write (not UpdateState blob) after each call"
  - "Agent1 loads CatalogDigest for tenant context — not critical, works without it"
  - "Agent1 passes enriched query (with <catalog> + <state> blocks) to LLM, raw query to conversation history"
  - "Agent1 extracts RenderConfig from current formation to provide display context"
  - "AddDelta auto-assigns step — no manual state.Step++ needed"
  - "Agent1 filters tools to catalog_* and _internal_* via getAgent1Tools()"
  - "Agent2 filters tools to render_* and freestyle via getAgent2Tools()"
  - "Pipeline generates TurnID (uuid) for delta grouping if not provided"
  - "Navigation uses zone-writes (UpdateView, UpdateTemplate) not blob UpdateState"
  - "Pipeline creates SpanCollector and attaches to context — all downstream agents/adapters emit spans"
  - "Each agent sets WithStage(ctx, 'agent1'/'agent2') — Anthropic adapter uses stage for span naming"
  - "Pipeline records trace.Spans = sc.Spans() before recording trace"

naming: "{domain}_{action}.go"
