# Backend Pipeline Expertise
# Tools, prompts, agents for two-agent pipeline

overview:
  layer: "pipeline"
  paths:
    tools: "project/backend/internal/tools/"
    prompts: "project/backend/internal/prompts/"
  purpose: "LLM tool calling and prompt management"

tools:
  path: "internal/tools/"
  imports: "domain/, ports/"

  registry:
    file: "tool_registry.go"
    struct: "Registry"
    purpose: "Central registry for all tool executors"
    methods:
      - "NewRegistry(statePort, catalogPort, presetRegistry)"
      - "Register(tool)"
      - "GetDefinitions() []ToolDefinition — includes padding tools from GetCachePaddingTools()"
      - "Execute(ctx, toolCtx ToolContext, toolCall) (*ToolResult, error)"

  mock_tools:
    file: "mock_tools.go"
    purpose: "Padding tools to reach 4096 token cache threshold"
    var: "CachePaddingEnabled bool (default true)"
    function: "GetCachePaddingTools() []ToolDefinition"
    tools_count: 20
    prefix: "_internal_ — LLM should never call these"
    estimated_tokens: "~5500 tokens (safely above 4096 min for Haiku 4.5)"
    note: "TODO: remove when real tools exceed 4096 threshold"

  search_products:
    file: "tool_search_products.go"
    struct: "SearchProductsTool"
    implements: "ToolExecutor"
    purpose: "Search products and write to state"
    input_schema:
      query: "required - search query"
      category: "optional - category filter"
      brand: "optional - brand filter"
      min_price: "optional - minimum price"
      max_price: "optional - maximum price"
      limit: "optional - max results (default 10)"
    returns: "'ok: found N products' or 'empty: 0 results, previous data preserved'"
    test_file: "tool_search_products_test.go"

  render_preset:
    file: "tool_render_preset.go"
    structs:
      - "RenderProductPresetTool"
      - "RenderServicePresetTool"
    implements: "ToolExecutor"
    purpose: "Render products/services using preset templates"
    product_presets: ["product_grid", "product_card", "product_compact", "product_detail"]
    service_presets: ["service_card", "service_list", "service_detail"]
    flow:
      - "Get preset from registry"
      - "Get state (products/services)"
      - "Build formation from preset + data"
      - "Write formation to state.Template"
    returns: "'ok: rendered N items with preset_name'"
    exported:
      - "BuildFormation(preset, count, getEntity EntityGetterFunc) *FormationWithData — generic builder, used by navigation usecases"
      - "EntityGetterFunc func(i int) (FieldGetter, CurrencyGetter, IDGetter) — entity accessor type"
      - "FieldGetter func(fieldName string) interface{} — extracts field value from entity"
      - "CurrencyGetter func() string — extracts currency from entity"
      - "IDGetter func() string — extracts entity ID"
    test_file: "tool_render_preset_test.go"

  freestyle:
    file: "tool_freestyle.go"
    struct: "FreestyleTool"
    implements: "ToolExecutor"
    purpose: "Render atoms with custom style aliases or explicit display overrides (Agent2 tool)"
    input_schema:
      entity_type: "required - 'product' or 'service'"
      formation: "required - 'grid', 'list', 'carousel', or 'single'"
      style: "optional - style alias (product-hero, product-compact, product-detail, service-card, service-detail)"
      overrides: "optional - slot->display map for explicit display overrides"
      limit: "optional - max entities to render (default: all)"
    returns: "'ok: rendered N entity_types with freestyle style=X, formation=Y'"

  interface:
    name: "ToolExecutor"
    methods:
      - "Definition() ToolDefinition"
      - "Execute(ctx context.Context, toolCtx ToolContext, input map[string]interface{}) (*ToolResult, error)"

presets:
  path: "internal/presets/"
  imports: "domain/"

  registry:
    file: "preset_registry.go"
    struct: "PresetRegistry"
    methods:
      - "NewPresetRegistry()"
      - "Register(preset)"
      - "Get(name) (Preset, bool)"
      - "GetByEntityType(entityType) []Preset"
      - "List() []PresetName"

  product_presets:
    file: "product_presets.go"
    presets: ["product_grid", "product_card", "product_compact", "product_detail"]

  service_presets:
    file: "service_presets.go"
    presets: ["service_card", "service_list", "service_detail"]

prompts:
  path: "internal/prompts/"
  imports: "domain/ (for types only)"

  agent1:
    file: "prompt_analyze_query.go"
    const: "Agent1SystemPrompt"
    purpose: "System prompt for Agent 1 (Tool Caller)"
    rules:
      - "ALWAYS call a tool, never just text"
      - "No explanations or clarifying questions"
      - "Tool results are 'ok' or 'empty' only"
      - "Stop after getting tool result"

  agent2:
    file: "prompt_compose_widgets.go"
    consts:
      - "Agent2SystemPrompt — system prompt for text-based template building"
      - "Agent2ToolSystemPrompt — system prompt for tool-based preset rendering"
    functions:
      - "BuildAgent2Prompt(meta StateMeta, layoutHint string) string — builds user message for text-based Agent2"
      - "BuildAgent2ToolPrompt(meta StateMeta, view ViewState, userQuery string, dataDelta *Delta) string — builds user message for tool-based Agent2"
    purpose: "System prompts for Agent 2 (Template Builder / Preset Renderer)"
    rules:
      - "ONLY output valid JSON, no explanations"
      - "Use fields that exist in input"
      - "Choose widget size based on atom count"
      - "Choose mode based on count (1→single, 2-6→grid, 7+→grid preferred, carousel only if asked)"

pipeline_flow:
  description: "User Query → Agent 1 → Agent 2 → Formation"
  steps:
    1: "Agent 1 receives query, calls search_products tool"
    2: "Tool writes products to state.data, returns 'ok'"
    3: "Agent 2 receives meta (count, fields), generates template JSON"
    4: "ApplyTemplate merges template + data → FormationWithData"
    5: "Frontend renders FormationWithData"

logger:
  path: "internal/logger/"
  file: "logger.go"
  struct: "Logger"
  methods:
    - "New(level) *Logger"
    - "ChatMessageReceived(sessionID, message)"
    - "LLMRequestStarted(stage)"
    - "LLMResponseReceived(stage, tokens, durationMs)"
    - "LLMUsage(stage, model, inputTokens, outputTokens, costUSD, durationMs)"
    - "LLMUsageWithCache(stage, model, inputTokens, outputTokens, cacheCreated, cacheRead, costUSD, durationMs)"
    - "ToolExecuted(toolName, sessionID, result, durationMs)"
    - "Agent1Completed(sessionID, toolCalled, productsFound, totalTokens, costUSD, durationMs)"

gotchas:
  - "If brand specified, don't use query as search (AND conflict). Multi-word queries split into words with OR"
  - "Tool writes to state, returns only status string"
  - "Must resolve tenant slug → UUID before search"
  - "Agent2 never sees raw data, only meta"
  - "Padding tools use _internal_ prefix — LLM ignores them"
  - "GetDefinitions() always includes padding tools when CachePaddingEnabled=true"
  - "ToolExecutor.Execute receives ToolContext (SessionID+TurnID+ActorID), not bare sessionID"
  - "Freestyle tool uses domain.DisplayStyles map for style alias → slot/display mapping"
  - "Agent2ToolPrompt includes data_change=null when no data changed — signals Agent2 to use freestyle for restyle"

naming:
  tools: "tool_{name}.go"
  prompts: "prompt_{name}.go"
