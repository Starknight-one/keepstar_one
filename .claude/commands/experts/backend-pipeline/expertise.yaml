# Backend Pipeline Expertise
# Tools, prompts, agents for two-agent pipeline

overview:
  layer: "pipeline"
  paths:
    tools: "project/backend/internal/tools/"
    prompts: "project/backend/internal/prompts/"
  purpose: "LLM tool calling and prompt management"

tools:
  path: "internal/tools/"
  imports: "domain/, ports/"

  registry:
    file: "tool_registry.go"
    struct: "Registry"
    purpose: "Central registry for all tool executors"
    methods:
      - "NewRegistry(statePort, catalogPort, presetRegistry)"
      - "Register(tool)"
      - "GetDefinitions() []ToolDefinition — includes padding tools from GetCachePaddingTools()"
      - "Execute(ctx, toolCtx ToolContext, toolCall) (*ToolResult, error)"

  mock_tools:
    file: "mock_tools.go"
    purpose: "Padding tools to reach 4096 token cache threshold"
    var: "CachePaddingEnabled bool (default true)"
    function: "GetCachePaddingTools() []ToolDefinition"
    tools_count: 20
    prefix: "_internal_ — LLM should never call these"
    estimated_tokens: "~5500 tokens (safely above 4096 min for Haiku 4.5)"
    note: "TODO: remove when real tools exceed 4096 threshold"

  search_products:
    file: "tool_search_products.go"
    struct: "SearchProductsTool"
    implements: "ToolExecutor"
    purpose: "Search products and write to state"
    input_schema:
      query: "required - search query"
      category: "optional - category filter"
      brand: "optional - brand filter"
      min_price: "optional - minimum price"
      max_price: "optional - maximum price"
      limit: "optional - max results (default 10)"
    returns: "'ok: found N products' or 'empty: 0 results, previous data preserved'"
    test_file: "tool_search_products_test.go"

  render_preset:
    file: "tool_render_preset.go"
    structs:
      - "RenderProductPresetTool"
      - "RenderServicePresetTool"
    implements: "ToolExecutor"
    purpose: "Render products/services using preset templates"
    product_presets: ["product_grid", "product_card", "product_compact", "product_detail"]
    service_presets: ["service_card", "service_list", "service_detail"]
    flow:
      - "Get preset from registry"
      - "Get state (products/services)"
      - "Build formation from preset + data"
      - "Write formation to state.Template"
    returns: "'ok: rendered N items with preset_name'"
    exported:
      - "BuildFormation(preset, count, getEntity EntityGetterFunc) *FormationWithData — generic builder, used by navigation usecases"
      - "EntityGetterFunc func(i int) (FieldGetter, CurrencyGetter, IDGetter) — entity accessor type"
      - "FieldGetter func(fieldName string) interface{} — extracts field value from entity"
      - "CurrencyGetter func() string — extracts currency from entity"
      - "IDGetter func() string — extracts entity ID"
    test_file: "tool_render_preset_test.go"

  freestyle:
    file: "tool_freestyle.go"
    struct: "FreestyleTool"
    implements: "ToolExecutor"
    purpose: "Render atoms with custom style aliases or explicit display overrides (Agent2 tool)"
    input_schema:
      entity_type: "required - 'product' or 'service'"
      formation: "required - 'grid', 'list', 'carousel', or 'single'"
      style: "optional - style alias (product-hero, product-compact, product-detail, service-card, service-detail)"
      overrides: "optional - slot->display map for explicit display overrides"
      limit: "optional - max entities to render (default: all)"
    returns: "'ok: rendered N entity_types with freestyle style=X, formation=Y'"

  catalog_search:
    file: "tool_catalog_search.go"
    struct: "CatalogSearchTool"
    implements: "ToolExecutor"
    purpose: "Meta-tool: normalize query → filter → SQL → fallback cascade → state write"
    input_schema:
      query: "required - search text in ANY language (normalized automatically)"
      brand: "optional - brand in ANY language/transliteration (normalized automatically)"
      category: "optional - category filter"
      min_price: "optional - minimum price in RUBLES (converted to kopecks internally)"
      max_price: "optional - maximum price in RUBLES (converted to kopecks internally)"
      sort_by: "optional - price, rating, or name"
      sort_order: "optional - asc or desc (default asc)"
      limit: "optional - max results (default 10)"
    flow:
      - "Parse input and convert prices (rubles→kopecks ×100)"
      - "Normalize query+brand via QueryNormalizer (fast path or LLM)"
      - "Strip brand from search to avoid AND conflict"
      - "Resolve tenant slug → UUID from state aliases"
      - "Search with fallback cascade: full → brand-only → search-only → empty"
      - "Write products to state via UpdateData zone-write"
    fallback_cascade: "step 0=direct hit, 1=brand-only, 2=search-only, 3=empty"
    returns: "'ok: found N products' or 'empty: 0 results, previous data preserved'"
    metadata: "Includes normalize_ms, normalize_path (fast/llm), sql_ms, fallback_step, price_conversion, sql_filter, tenant"

  normalizer:
    file: "normalizer.go"
    struct: "QueryNormalizer"
    types: ["NormalizeResult { Query, Brand, SourceLang, AliasResolved }"]
    purpose: "Normalize search queries via fast path (ASCII) or LLM (non-ASCII)"
    methods:
      - "Normalize(ctx, query, brand) (*NormalizeResult, error)"
    fast_path: "ASCII-only input → return as-is, lang=en"
    llm_path: "Non-ASCII → call LLM with NormalizeQueryPrompt, parse JSON"
    helpers: ["isASCII(s)", "stripCodeFences(s)"]

  interface:
    name: "ToolExecutor"
    methods:
      - "Definition() ToolDefinition"
      - "Execute(ctx context.Context, toolCtx ToolContext, input map[string]interface{}) (*ToolResult, error)"

presets:
  path: "internal/presets/"
  imports: "domain/"

  registry:
    file: "preset_registry.go"
    struct: "PresetRegistry"
    methods:
      - "NewPresetRegistry()"
      - "Register(preset)"
      - "Get(name) (Preset, bool)"
      - "GetByEntityType(entityType) []Preset"
      - "List() []PresetName"

  product_presets:
    file: "product_presets.go"
    presets: ["product_grid", "product_card", "product_compact", "product_detail"]

  service_presets:
    file: "service_presets.go"
    presets: ["service_card", "service_list", "service_detail"]

prompts:
  path: "internal/prompts/"
  imports: "domain/ (for types only)"

  agent1:
    file: "prompt_analyze_query.go"
    const: "Agent1SystemPrompt"
    purpose: "System prompt for Agent 1 (Tool Caller)"
    rules:
      - "ALWAYS call a tool, never just text"
      - "No explanations or clarifying questions"
      - "Tool results are 'ok' or 'empty' only"
      - "Stop after getting tool result"

  agent2:
    file: "prompt_compose_widgets.go"
    consts:
      - "Agent2SystemPrompt — system prompt for text-based template building"
      - "Agent2ToolSystemPrompt — system prompt for tool-based preset rendering"
    functions:
      - "BuildAgent2Prompt(meta StateMeta, layoutHint string) string — builds user message for text-based Agent2"
      - "BuildAgent2ToolPrompt(meta StateMeta, view ViewState, userQuery string, dataDelta *Delta) string — builds user message for tool-based Agent2"
    purpose: "System prompts for Agent 2 (Template Builder / Preset Renderer)"
    rules:
      - "ONLY output valid JSON, no explanations"
      - "Use fields that exist in input"
      - "Choose widget size based on atom count"
      - "Choose mode based on count (1→single, 2-6→grid, 7+→grid preferred, carousel only if asked)"

  normalize_query:
    file: "prompt_normalize_query.go"
    const: "NormalizeQueryPrompt"
    function: "BuildNormalizeRequest(query, brand) string"
    purpose: "System prompt for query normalization LLM call"
    features:
      - "Alias table: Russian slang → English (кроссы→sneakers, ноутбук→laptop, etc.)"
      - "Brand transliteration table: Russian → English (Найк→Nike, Самсунг→Samsung, etc.)"
      - "Returns structured JSON: { query, brand, source_lang, alias_resolved }"

pipeline_flow:
  description: "User Query → Agent 1 → Agent 2 → Formation"
  steps:
    1: "Agent 1 receives query, calls search_products tool"
    2: "Tool writes products to state.data, returns 'ok'"
    3: "Agent 2 receives meta (count, fields), generates template JSON"
    4: "ApplyTemplate merges template + data → FormationWithData"
    5: "Frontend renders FormationWithData"

logger:
  path: "internal/logger/"
  file: "logger.go"
  struct: "Logger"
  methods:
    - "New(level) *Logger"
    - "ChatMessageReceived(sessionID, message)"
    - "LLMRequestStarted(stage)"
    - "LLMResponseReceived(stage, tokens, durationMs)"
    - "LLMUsage(stage, model, inputTokens, outputTokens, costUSD, durationMs)"
    - "LLMUsageWithCache(stage, model, inputTokens, outputTokens, cacheCreated, cacheRead, costUSD, durationMs)"
    - "ToolExecuted(toolName, sessionID, result, durationMs)"
    - "Agent1Completed(sessionID, toolCalled, productsFound, totalTokens, costUSD, durationMs)"

gotchas:
  - "If brand specified, don't use query as search (AND conflict). Multi-word queries split into words with OR"
  - "Tool writes to state, returns only status string"
  - "Must resolve tenant slug → UUID before search"
  - "Agent2 never sees raw data, only meta"
  - "Padding tools use _internal_ prefix — LLM ignores them"
  - "GetDefinitions() always includes padding tools when CachePaddingEnabled=true"
  - "ToolExecutor.Execute receives ToolContext (SessionID+TurnID+ActorID), not bare sessionID"
  - "Freestyle tool uses domain.DisplayStyles map for style alias → slot/display mapping"
  - "Agent2ToolPrompt includes data_change=null when no data changed — signals Agent2 to use freestyle for restyle"
  - "catalog_search is the preferred search tool (replaces search_products for Agent1)"
  - "catalog_search normalizes non-ASCII queries via LLM, ASCII via fast path (no LLM cost)"
  - "catalog_search converts prices rubles→kopecks (×100) before SQL filter"
  - "catalog_search fallback cascade: full → brand-only → search-only → empty"
  - "catalog_search metadata includes full tool breakdown for pipeline tracing"

naming:
  tools: "tool_{name}.go"
  prompts: "prompt_{name}.go"
