# Backend Pipeline Expertise
# Tools, prompts, agents for two-agent pipeline

overview:
  layer: "pipeline"
  paths:
    tools: "project/backend/internal/tools/"
    prompts: "project/backend/internal/prompts/"
  purpose: "LLM tool calling and prompt management"

tools:
  path: "internal/tools/"
  imports: "domain/, ports/"

  registry:
    file: "tool_registry.go"
    struct: "Registry"
    fields: ["tools map[string]ToolExecutor", "statePort", "catalogPort", "presetRegistry", "embeddingPort"]
    purpose: "Central registry for all tool executors"
    methods:
      - "NewRegistry(statePort, catalogPort, presetRegistry, embeddingPort)"
      - "Register(tool)"
      - "GetDefinitions() []ToolDefinition — includes padding tools from GetCachePaddingTools()"
      - "Execute(ctx, toolCtx ToolContext, toolCall) (*ToolResult, error)"
    registered_tools:
      - "CatalogSearchTool (Agent1)"
      - "RenderProductPresetTool (Agent2)"
      - "RenderServicePresetTool (Agent2)"
      - "FreestyleTool (Agent2)"

  mock_tools:
    file: "mock_tools.go"
    purpose: "Padding tools to reach 4096 token cache threshold"
    var: "CachePaddingEnabled bool (default true)"
    function: "GetCachePaddingTools() []ToolDefinition"
    tools_count: 20
    prefix: "_internal_ — LLM should never call these"
    estimated_tokens: "~5500 tokens (safely above 4096 min for Haiku 4.5)"
    note: "TODO: remove when real tools exceed 4096 threshold"

  search_products:
    file: "tool_search_products.go"
    struct: "SearchProductsTool"
    implements: "ToolExecutor"
    purpose: "Search products and write to state (legacy, not registered in Registry)"
    input_schema:
      query: "required - search query"
      category: "optional - category filter"
      brand: "optional - brand filter"
      min_price: "optional - minimum price"
      max_price: "optional - maximum price"
      limit: "optional - max results (default 10)"
    returns: "'ok: found N products' or 'empty: 0 results, previous data preserved'"
    test_file: "tool_search_products_test.go"

  render_preset:
    file: "tool_render_preset.go"
    structs:
      - "RenderProductPresetTool"
      - "RenderServicePresetTool"
    implements: "ToolExecutor"
    purpose: "Render products/services using preset templates"
    product_presets: ["product_grid", "product_card", "product_compact", "product_detail"]
    service_presets: ["service_card", "service_list", "service_detail"]
    flow:
      - "Get preset from registry"
      - "Get state (products/services)"
      - "Build formation from preset + data"
      - "Write formation to state.Template"
    returns: "'ok: rendered N items with preset_name'"
    exported:
      - "BuildFormation(preset, count, getEntity EntityGetterFunc) *FormationWithData — generic builder, used by navigation usecases"
      - "EntityGetterFunc func(i int) (FieldGetter, CurrencyGetter, IDGetter) — entity accessor type"
      - "FieldGetter func(fieldName string) interface{} — extracts field value from entity"
      - "CurrencyGetter func() string — extracts currency from entity"
      - "IDGetter func() string — extracts entity ID"
    test_file: "tool_render_preset_test.go"

  freestyle:
    file: "tool_freestyle.go"
    struct: "FreestyleTool"
    implements: "ToolExecutor"
    purpose: "Render atoms with custom style aliases or explicit display overrides (Agent2 tool)"
    input_schema:
      entity_type: "required - 'product' or 'service'"
      formation: "required - 'grid', 'list', 'carousel', or 'single'"
      style: "optional - style alias (product-hero, product-compact, product-detail, service-card, service-detail)"
      overrides: "optional - slot->display map for explicit display overrides"
      limit: "optional - max entities to render (default: all)"
    returns: "'ok: rendered N entity_types with freestyle style=X, formation=Y'"

  catalog_search:
    file: "tool_catalog_search.go"
    struct: "CatalogSearchTool"
    implements: "ToolExecutor"
    fields: ["statePort", "catalogPort", "embedding ports.EmbeddingPort (nil = keyword-only mode)"]
    purpose: "Hybrid search meta-tool: keyword SQL + vector pgvector + RRF merge → state write"
    constructor: "NewCatalogSearchTool(statePort, catalogPort, embedding)"
    input_schema:
      vector_query: "required - semantic search in user's ORIGINAL language (embeddings handle multilingual)"
      filters:
        type: "object - exact keyword filters"
        brand: "optional - brand in English (e.g. Nike, Samsung)"
        category: "optional - category (e.g. Sneakers, Laptops)"
        min_price: "optional - minimum price in RUBLES (converted to kopecks internally)"
        max_price: "optional - maximum price in RUBLES (converted to kopecks internally)"
        color: "optional - color in English (e.g. Black, White)"
        material: "optional - material (e.g. Leather, Mesh)"
        storage: "optional - storage capacity (e.g. 128GB, 256GB)"
        ram: "optional - RAM size (e.g. 8GB, 16GB)"
        size: "optional - size (e.g. 11 inch, 44mm)"
      sort_by: "optional - price, rating, or name"
      sort_order: "optional - asc or desc (default asc)"
      limit: "optional - max results (default 10)"
    flow:
      - "Parse input and convert prices (rubles→kopecks ×100)"
      - "Generate query embedding via EmbeddingPort (if available)"
      - "Strip brand from ILIKE search to avoid AND conflict"
      - "Resolve tenant slug → UUID from state aliases"
      - "Keyword search via catalogPort.ListProducts (SQL ILIKE)"
      - "Vector search via catalogPort.VectorSearch (pgvector cosine)"
      - "RRF merge: combine keyword + vector results with Reciprocal Rank Fusion (k=60)"
      - "Write products to state via UpdateData zone-write"
    search_modes: "hybrid (both), vector (embedding only), keyword (SQL only / embedding nil)"
    returns: "'ok: found N products' or 'empty: 0 results, previous data preserved'"
    metadata: "Includes embed_ms, sql_ms, vector_ms, keyword_count, vector_count, merged_count, search_type, price_conversion, tenant"
    helpers:
      - "rrfMerge(keyword, vector []Product, limit) []Product — Reciprocal Rank Fusion merge"
      - "catalogExtractProductFields(p Product) []string — extract field names from product"

  interface:
    name: "ToolExecutor"
    methods:
      - "Definition() ToolDefinition"
      - "Execute(ctx context.Context, toolCtx ToolContext, input map[string]interface{}) (*ToolResult, error)"

presets:
  path: "internal/presets/"
  imports: "domain/"

  registry:
    file: "preset_registry.go"
    struct: "PresetRegistry"
    methods:
      - "NewPresetRegistry()"
      - "Register(preset)"
      - "Get(name) (Preset, bool)"
      - "GetByEntityType(entityType) []Preset"
      - "List() []PresetName"

  product_presets:
    file: "product_presets.go"
    presets: ["product_grid", "product_card", "product_compact", "product_detail"]

  service_presets:
    file: "service_presets.go"
    presets: ["service_card", "service_list", "service_detail"]

prompts:
  path: "internal/prompts/"
  imports: "domain/ (for types only)"

  agent1:
    file: "prompt_analyze_query.go"
    consts:
      - "Agent1SystemPrompt — primary system prompt for Agent 1 (hybrid search with vector_query + filters)"
      - "AnalyzeQuerySystemPrompt — legacy system prompt for query analysis (backward compat)"
      - "AnalyzeQueryUserTemplate — legacy user template (backward compat)"
    functions:
      - "BuildAnalyzeQueryPrompt(query string) string — legacy, returns empty (TODO)"
    purpose: "System prompt for Agent 1 (Data Retrieval via catalog_search)"
    rules:
      - "Call catalog_search when user needs NEW data"
      - "vector_query: user's ORIGINAL language (do NOT translate)"
      - "filters: structured keyword filters in English (brand, color, material, etc.)"
      - "Prices are in RUBLES"
      - "If user asks to change display style → do NOT call any tool"
      - "No explanations or clarifying questions"
      - "Stop after getting tool result"

  agent2:
    file: "prompt_compose_widgets.go"
    consts:
      - "Agent2SystemPrompt — system prompt for text-based template building"
      - "Agent2ToolSystemPrompt — system prompt for tool-based preset rendering"
    functions:
      - "BuildAgent2Prompt(meta StateMeta, layoutHint string) string — builds user message for text-based Agent2"
      - "BuildAgent2ToolPrompt(meta StateMeta, view ViewState, userQuery string, dataDelta *Delta) string — builds user message for tool-based Agent2"
    purpose: "System prompts for Agent 2 (Template Builder / Preset Renderer)"
    rules:
      - "ONLY output valid JSON, no explanations"
      - "Use fields that exist in input"
      - "Choose widget size based on atom count"
      - "Choose mode based on count (1→single, 2-6→grid, 7+→grid preferred, carousel only if asked)"

pipeline_flow:
  description: "User Query → Agent 1 → Agent 2 → Formation"
  steps:
    1: "Agent 1 receives query, calls catalog_search (hybrid: keyword + vector)"
    2: "catalog_search: embed query → SQL ILIKE + pgvector cosine → RRF merge → state write"
    3: "Tool returns 'ok: found N products', Agent 1 stops"
    4: "Agent 2 receives meta (count, fields), generates template JSON"
    5: "ApplyTemplate merges template + data → FormationWithData"
    6: "Frontend renders FormationWithData"

logger:
  path: "internal/logger/"
  file: "logger.go"
  struct: "Logger"
  methods:
    - "New(level) *Logger"
    - "ChatMessageReceived(sessionID, message)"
    - "LLMRequestStarted(stage)"
    - "LLMResponseReceived(stage, tokens, durationMs)"
    - "LLMUsage(stage, model, inputTokens, outputTokens, costUSD, durationMs)"
    - "LLMUsageWithCache(stage, model, inputTokens, outputTokens, cacheCreated, cacheRead, costUSD, durationMs)"
    - "ToolExecuted(toolName, sessionID, result, durationMs)"
    - "Agent1Completed(sessionID, toolCalled, productsFound, totalTokens, costUSD, durationMs)"

gotchas:
  - "If brand specified, strip it from ILIKE search to avoid AND conflict"
  - "Tool writes to state, returns only status string"
  - "Must resolve tenant slug → UUID before search"
  - "Agent2 never sees raw data, only meta"
  - "Padding tools use _internal_ prefix — LLM ignores them"
  - "GetDefinitions() always includes padding tools when CachePaddingEnabled=true"
  - "ToolExecutor.Execute receives ToolContext (SessionID+TurnID+ActorID), not bare sessionID"
  - "Freestyle tool uses domain.DisplayStyles map for style alias → slot/display mapping"
  - "Agent2ToolPrompt includes data_change=null when no data changed — signals Agent2 to use freestyle for restyle"
  - "catalog_search is the ONLY registered search tool (SearchProductsTool file exists but is not registered)"
  - "catalog_search uses vector embeddings via EmbeddingPort (nil = keyword-only fallback)"
  - "catalog_search converts prices rubles→kopecks (×100) before SQL filter"
  - "catalog_search RRF merge combines keyword + vector results (k=60)"
  - "catalog_search metadata includes full tool breakdown for pipeline tracing (embed_ms, sql_ms, vector_ms, search_type)"
  - "vector_query is in user's ORIGINAL language — embeddings handle multilingual matching"
  - "filters.brand/color/material etc. must be in English — LLM translates from user's language"
  - "JSONB attribute filters (color, material, storage, ram, size) use ILIKE on p.attributes"
  - "normalizer.go and prompt_normalize_query.go are REMOVED — vector search replaces LLM normalization"

naming:
  tools: "tool_{name}.go"
  prompts: "prompt_{name}.go"
