# Backend Implementation Expertise
# Keepstar - Go Hexagonal Architecture

overview:
  description: "Go REST API with hexagonal architecture for AI-powered chat widget"
  architecture: "Hexagonal (Ports & Adapters)"
  language: "Go 1.21+"
  port: 8080
  ai_provider: "Anthropic Claude"
  model: "claude-haiku-4-5-20251001"
  database: "Neon PostgreSQL"

project_structure:
  root: "project/backend/"
  entry: "cmd/server/main.go"

  layers:
    domain: "internal/domain/"
    ports: "internal/ports/"
    adapters: "internal/adapters/"
    usecases: "internal/usecases/"
    handlers: "internal/handlers/"
    prompts: "internal/prompts/"
    logger: "internal/logger/"
    config: "internal/config/"

  data: "data/products.json"

layer_rules:
  description: "Dependency direction: handlers → usecases → ports ← adapters, all depend on domain"
  domain:
    imports: "Nothing from internal/"
    contains: "Entities, types, domain errors"
  ports:
    imports: "Only domain/"
    contains: "Interfaces (contracts)"
  usecases:
    imports: "domain/, ports/"
    contains: "Business logic, 1 file = 1 use case"
  adapters:
    imports: "domain/, ports/, external libraries"
    contains: "Port implementations"
  handlers:
    imports: "Everything above + http libraries"
    contains: "HTTP layer, only parse/validate/respond"
  prompts:
    imports: "domain/ (for types)"
    contains: "LLM prompts, separate from logic"

core_implementation:
  main:
    file: "cmd/server/main.go"
    purpose: "Application bootstrap"
    pattern: |
      - Load .env via godotenv
      - Load config
      - Initialize PostgreSQL client (if DATABASE_URL set)
      - Run migrations
      - Initialize adapters (anthropic, postgres)
      - Initialize usecases (sendMessage)
      - Initialize handlers
      - Setup routes
      - Apply CORS middleware
      - Start server with graceful shutdown

  ports:
    llm_port:
      file: "internal/ports/llm_port.go"
      interface: "LLMPort"
      methods:
        - "Chat(ctx context.Context, message string) (string, error)"

    search_port:
      file: "internal/ports/search_port.go"
      interface: "SearchPort"
      status: "stub"

    cache_port:
      file: "internal/ports/cache_port.go"
      interface: "CachePort"
      status: "implemented"
      methods:
        - "GetSession(ctx, id) (*Session, error)"
        - "SaveSession(ctx, session) error"
        - "CacheProducts(ctx, sessionID, products) error"
        - "GetCachedProducts(ctx, sessionID) ([]Product, error)"

    event_port:
      file: "internal/ports/event_port.go"
      interface: "EventPort"
      status: "implemented"
      methods:
        - "TrackEvent(ctx, event) error"
        - "GetSessionEvents(ctx, sessionID) ([]ChatEvent, error)"

    catalog_port:
      file: "internal/ports/catalog_port.go"
      interface: "CatalogPort"
      status: "implemented"
      methods:
        - "GetTenantBySlug(ctx, slug) (*Tenant, error)"
        - "GetCategories(ctx) ([]Category, error)"
        - "GetMasterProduct(ctx, id) (*MasterProduct, error)"
        - "ListProducts(ctx, tenantID, filter) ([]Product, int, error)"
        - "GetProduct(ctx, tenantID, productID) (*Product, error)"
      types:
        - "ProductFilter: CategoryID, Brand, MinPrice, MaxPrice, Search, Limit, Offset"

    state_port:
      file: "internal/ports/state_port.go"
      interface: "StatePort"
      status: "implemented"
      methods:
        - "CreateState(ctx, sessionID) (*SessionState, error)"
        - "GetState(ctx, sessionID) (*SessionState, error)"
        - "UpdateState(ctx, state) error"
        - "AddDelta(ctx, sessionID, delta) error"
        - "GetDeltas(ctx, sessionID) ([]Delta, error)"
        - "GetDeltasSince(ctx, sessionID, fromStep) ([]Delta, error)"

  adapters:
    anthropic:
      file: "internal/adapters/anthropic/anthropic_client.go"
      implements: "LLMPort"
      status: "implemented"
      method: "Chat(ctx, message) (string, error)"
      api: "POST https://api.anthropic.com/v1/messages"

    postgres:
      directory: "internal/adapters/postgres/"
      status: "implemented"
      files:
        - "postgres_client.go - Connection pool (pgxpool)"
        - "postgres_cache.go - CachePort implementation"
        - "postgres_events.go - EventPort implementation"
        - "migrations.go - Auto-migrations for chat tables"
        - "postgres_catalog.go - CatalogPort implementation with product merging"
        - "catalog_migrations.go - Catalog schema migrations"
        - "catalog_seed.go - Seed data (tenants, categories, products)"
        - "postgres_state.go - StatePort implementation with JSONB storage"
        - "state_migrations.go - State table migrations"
        - "postgres_state_test.go - State repository tests"

    json_store:
      file: "internal/adapters/json_store/json_product_store.go"
      implements: "SearchPort"
      status: "stub"

    memory:
      file: "internal/adapters/memory/memory_cache.go"
      implements: "CachePort"
      status: "stub (replaced by postgres)"

  usecases:
    chat_send_message:
      file: "internal/usecases/chat_send_message.go"
      struct: "SendMessageUseCase"
      purpose: "Send message to LLM, save to DB, track events"
      status: "implemented"
      methods:
        - "Execute(ctx, req) (*SendMessageResponse, error)"
        - "WithSessionTTL(duration) *SendMessageUseCase"
      features:
        - "Session management with sliding TTL (10 min default)"
        - "Message persistence to PostgreSQL"
        - "Event tracking (chat_opened, message_sent, message_received)"
        - "Graceful handling when DB not configured"

    catalog_list_products:
      file: "internal/usecases/catalog_list_products.go"
      struct: "ListProductsUseCase"
      purpose: "List products for tenant with filtering"
      status: "implemented"
      methods:
        - "Execute(ctx, req) (*ListProductsResponse, error)"

    catalog_get_product:
      file: "internal/usecases/catalog_get_product.go"
      struct: "GetProductUseCase"
      purpose: "Get single product with master data merging"
      status: "implemented"
      methods:
        - "Execute(ctx, req) (*Product, error)"

  handlers:
    chat:
      file: "internal/handlers/handler_chat.go"
      struct: "ChatHandler"
      endpoint: "POST /api/v1/chat"
      request: "{ sessionId?: string, tenantId?: string, message: string }"
      response: "{ sessionId: string, response: string, latencyMs: int }"
      status: "implemented"

    session:
      file: "internal/handlers/handler_session.go"
      struct: "SessionHandler"
      endpoint: "GET /api/v1/session/{id}"
      response: "{ id, status, messages[], startedAt, lastActivityAt }"
      status: "implemented"

    health:
      file: "internal/handlers/handler_health.go"
      endpoints:
        - "GET /health"
        - "GET /ready"

    catalog:
      file: "internal/handlers/handler_catalog.go"
      struct: "CatalogHandler"
      status: "implemented"
      endpoints:
        - "GET /api/v1/tenants/{slug}/products"
        - "GET /api/v1/tenants/{slug}/products/{id}"
      query_params: ["category", "brand", "minPrice", "maxPrice", "search", "limit", "offset"]

    middleware_tenant:
      file: "internal/handlers/middleware_tenant.go"
      struct: "TenantMiddleware"
      purpose: "Resolve tenant slug from URL, validate tenant exists"
      status: "implemented"

    response:
      file: "internal/handlers/response.go"
      purpose: "JSON response helper"
      functions: ["writeJSON(w, status, data)"]

  domain:
    atom_entity:
      file: "internal/domain/atom_entity.go"
      types: ["AtomType", "Atom"]

    widget_entity:
      file: "internal/domain/widget_entity.go"
      types: ["WidgetType", "Widget"]

    formation_entity:
      file: "internal/domain/formation_entity.go"
      types: ["FormationType", "Formation"]

    message_entity:
      file: "internal/domain/message_entity.go"
      types: ["MessageRole", "Message"]
      fields: ["ID", "SessionID", "Role", "Content", "Widgets", "Formation", "TokensUsed", "ModelUsed", "LatencyMs", "SentAt", "ReceivedAt", "Timestamp"]

    session_entity:
      file: "internal/domain/session_entity.go"
      types: ["SessionStatus", "Session"]
      fields: ["ID", "UserID", "TenantID", "Status", "Messages", "Metadata", "StartedAt", "EndedAt", "LastActivityAt", "CreatedAt", "UpdatedAt"]

    user_entity:
      file: "internal/domain/user_entity.go"
      types: ["ChatUser"]
      fields: ["ID", "ExternalID", "TenantID", "Fingerprint", "IPAddress", "UserAgent", "Metadata", "FirstSeenAt", "LastSeenAt", "CreatedAt"]

    event_entity:
      file: "internal/domain/event_entity.go"
      types: ["EventType", "ChatEvent"]
      event_types: ["chat_opened", "message_sent", "message_received", "chat_closed", "widget_clicked", "session_timeout"]

    product_entity:
      file: "internal/domain/product_entity.go"
      types: ["Product"]
      fields: ["ID", "TenantID", "MasterProductID", "Name", "Description", "Price", "PriceFormatted", "Currency", "Images", "Rating", "StockQuantity", "Brand", "Category", "Tags", "Attributes"]

    tenant_entity:
      file: "internal/domain/tenant_entity.go"
      types: ["TenantType", "Tenant"]
      tenant_types: ["brand", "retailer", "reseller"]
      fields: ["ID", "Slug", "Name", "Type", "Settings", "CreatedAt", "UpdatedAt"]

    category_entity:
      file: "internal/domain/category_entity.go"
      types: ["Category"]
      fields: ["ID", "Name", "Slug", "ParentID"]

    master_product_entity:
      file: "internal/domain/master_product_entity.go"
      types: ["MasterProduct"]
      fields: ["ID", "SKU", "Name", "Description", "Brand", "CategoryID", "Images", "Attributes", "OwnerTenantID", "CreatedAt", "UpdatedAt"]

    domain_errors:
      file: "internal/domain/domain_errors.go"
      errors: ["ErrSessionNotFound", "ErrProductNotFound", "ErrInvalidQuery", "ErrLLMUnavailable", "ErrTenantNotFound", "ErrCategoryNotFound"]

    state_entity:
      file: "internal/domain/state_entity.go"
      types: ["TriggerType", "ActionType", "Action", "ResultMeta", "Delta", "StateMeta", "StateData", "StateCurrent", "SessionState"]
      trigger_types: ["USER_QUERY", "WIDGET_ACTION", "SYSTEM"]
      action_types: ["SEARCH", "FILTER", "SORT", "LAYOUT", "ROLLBACK"]
      purpose: "Delta-based state for two-agent pipeline"

api_endpoints:
  chat:
    method: "POST"
    path: "/api/v1/chat"
    body: "{ sessionId?: string, tenantId?: string, message: string }"
    response: "{ sessionId: string, response: string, latencyMs: int }"

  session:
    method: "GET"
    path: "/api/v1/session/{id}"
    response: "{ id, status, messages[], startedAt, lastActivityAt }"

  catalog_list:
    method: "GET"
    path: "/api/v1/tenants/{slug}/products"
    query: "?category=&brand=&minPrice=&maxPrice=&search=&limit=&offset="
    response: "{ products: Product[], total: int }"

  catalog_get:
    method: "GET"
    path: "/api/v1/tenants/{slug}/products/{id}"
    response: "Product (merged with master)"

  health:
    method: "GET"
    path: "/health"
    response: "OK"

  ready:
    method: "GET"
    path: "/ready"
    response: "OK"

database:
  provider: "Neon PostgreSQL"
  schemas:
    public:
      tables:
        - "chat_users - User/visitor tracking"
        - "chat_sessions - Chat sessions with status and TTL"
        - "chat_messages - Message history with metadata"
        - "chat_events - Analytics events"
    catalog:
      tables:
        - "tenants - Multi-tenant support (brand, retailer, reseller)"
        - "categories - Product categories with tree structure"
        - "master_products - Canonical product definitions"
        - "products - Tenant-specific listings linked to masters"
  features:
    - "Auto-migrations on startup"
    - "Connection pooling (pgxpool)"
    - "SSL required for Neon"
    - "Graceful shutdown"
    - "Product merging (tenant + master data)"
    - "Seed data on first run"

patterns:
  naming:
    handlers: "handler_{name}.go"
    usecases: "{domain}_{action}.go"
    adapters: "{tech}_{purpose}.go"
    domain: "{entity}_entity.go"
    ports: "{name}_port.go"
    prompts: "prompt_{name}.go"

  handler_pattern:
    - "Parse request body"
    - "Validate input"
    - "Call use case"
    - "Return JSON response"

  usecase_pattern:
    - "Struct with port dependencies"
    - "NewXxxUseCase() constructor"
    - "Execute(ctx, req) method"

run_commands:
  start: "cd project/backend && go run ./cmd/server/"
  build: "cd project/backend && go build -o server ./cmd/server/"
  test: "cd project/backend && go test ./..."

dependencies:
  - "github.com/joho/godotenv"
  - "github.com/rs/cors"
  - "github.com/jackc/pgx/v5"
  - "github.com/google/uuid"

env_vars:
  required:
    - "ANTHROPIC_API_KEY"
  optional:
    - "PORT (default: 8080)"
    - "ENVIRONMENT (default: development)"
    - "LLM_MODEL (default: claude-haiku-4-5-20251001)"
    - "LOG_LEVEL (default: info)"
    - "DATABASE_URL (PostgreSQL connection string)"

migration_status:
  description: "Hexagonal architecture with PostgreSQL persistence and multi-tenant catalog"
  completed:
    - "Migrate to cmd/server/main.go entry point"
    - "Implement LLMPort with Chat method"
    - "Implement Anthropic adapter"
    - "Implement SendMessageUseCase"
    - "Implement ChatHandler"
    - "Add PostgreSQL adapter with connection pooling"
    - "Implement CachePort for session/message persistence"
    - "Implement EventPort for analytics"
    - "Add session TTL (10 min sliding)"
    - "Add GET /api/v1/session/{id} endpoint"
    - "Implement multi-tenant product catalog"
    - "Add CatalogPort with product merging"
    - "Add catalog migrations and seed data"
    - "Implement ListProducts and GetProduct use cases"
    - "Add TenantMiddleware for slug resolution"
    - "Add catalog API endpoints"
    - "Add StatePort interface for session state"
    - "Implement PostgreSQL state adapter with JSONB"
    - "Add state migrations and tests"
  next_steps:
    - "Add two-agent pipeline (Agent1 Tool Caller + Agent2 Template Builder)"
    - "Connect chat to product search via state"
    - "Add widget rendering for products"

# CRITICAL: Gotchas by hexagonal layer
gotchas:
  # Domain layer - entities, types, errors
  domain:
    - "Price stored in kopecks (int), not rubles (float)"
    - "sessionID and tenantID must be valid UUID format"
    - "ErrSessionNotFound returned when state doesn't exist"

  # Ports layer - interface contracts
  ports:
    - "CatalogPort.ListProducts(tenantID) requires UUID, not slug"
    - "Use GetTenantBySlug(slug) first to get tenant UUID"
    - "StatePort.GetState returns ErrSessionNotFound if no state"

  # Adapters layer - external system specifics
  adapters:
    postgres:
      - "FK: chat_session_state.session_id → chat_sessions.id"
      - "FK: chat_session_deltas.session_id → chat_sessions.id"
      - "FK: catalog.products.tenant_id → catalog.tenants.id"
      - "ProductFilter conditions are AND-combined"
      - "Search uses ILIKE with % wildcards"
    anthropic:
      - "API version: 2023-06-01 (not 2024)"
      - "Pricing: Haiku $1/$5, Sonnet $3/$15 per 1M tokens"
      - "Response includes usage.input_tokens, usage.output_tokens"

  # Usecases layer - orchestration rules
  usecases:
    - "Create session (CachePort) before creating state (StatePort)"
    - "Tools return 'ok'/'empty', not raw data"
    - "Agent1 stops after first tool call, doesn't see result"

  # Tools layer - tool execution specifics
  tools:
    - "If brand specified, don't use query as search (AND conflict)"
    - "Tool writes to state, returns only status string"
    - "Must resolve tenant slug → UUID before search"
