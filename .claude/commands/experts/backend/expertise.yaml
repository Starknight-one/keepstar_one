# Backend Implementation Expertise
# Keepstar - Go Hexagonal Architecture

overview:
  description: "Go REST API with hexagonal architecture for AI-powered chat widget"
  architecture: "Hexagonal (Ports & Adapters)"
  language: "Go 1.21+"
  port: 8080
  ai_provider: "Anthropic Claude"
  model: "claude-haiku-4-5-20251001"
  database: "Neon PostgreSQL"

project_structure:
  root: "project/backend/"
  entry: "cmd/server/main.go"

  layers:
    domain: "internal/domain/"
    ports: "internal/ports/"
    adapters: "internal/adapters/"
    usecases: "internal/usecases/"
    handlers: "internal/handlers/"
    prompts: "internal/prompts/"
    tools: "internal/tools/"
    logger: "internal/logger/"
    config: "internal/config/"

  data: "data/products.json"

layer_rules:
  description: "Dependency direction: handlers → usecases → ports ← adapters, all depend on domain"
  domain:
    imports: "Nothing from internal/"
    contains: "Entities, types, domain errors"
  ports:
    imports: "Only domain/"
    contains: "Interfaces (contracts)"
  usecases:
    imports: "domain/, ports/"
    contains: "Business logic, 1 file = 1 use case"
  adapters:
    imports: "domain/, ports/, external libraries"
    contains: "Port implementations"
  handlers:
    imports: "Everything above + http libraries"
    contains: "HTTP layer, only parse/validate/respond"
  prompts:
    imports: "domain/ (for types)"
    contains: "LLM prompts, separate from logic"
  tools:
    imports: "domain/, ports/"
    contains: "Tool executors for LLM tool calls"

core_implementation:
  main:
    file: "cmd/server/main.go"
    purpose: "Application bootstrap"
    pattern: |
      - Load .env via godotenv
      - Load config
      - Initialize PostgreSQL client (if DATABASE_URL set)
      - Run migrations
      - Initialize adapters (anthropic, postgres)
      - Initialize usecases (sendMessage)
      - Initialize handlers
      - Setup routes
      - Apply CORS middleware
      - Start server with graceful shutdown

  ports:
    llm_port:
      file: "internal/ports/llm_port.go"
      interface: "LLMPort"
      methods:
        - "Chat(ctx context.Context, message string) (string, error)"
        - "ChatWithTools(ctx, systemPrompt, messages []LLMMessage, tools []ToolDefinition) (*LLMResponse, error)"
        - "ChatWithUsage(ctx, systemPrompt, userMessage string) (*ChatResponse, error)"
      types:
        - "ChatResponse: { Text string, Usage LLMUsage }"

    search_port:
      file: "internal/ports/search_port.go"
      interface: "SearchPort"
      status: "stub"

    cache_port:
      file: "internal/ports/cache_port.go"
      interface: "CachePort"
      status: "implemented"
      methods:
        - "GetSession(ctx, id) (*Session, error)"
        - "SaveSession(ctx, session) error"
        - "CacheProducts(ctx, sessionID, products) error"
        - "GetCachedProducts(ctx, sessionID) ([]Product, error)"

    event_port:
      file: "internal/ports/event_port.go"
      interface: "EventPort"
      status: "implemented"
      methods:
        - "TrackEvent(ctx, event) error"
        - "GetSessionEvents(ctx, sessionID) ([]ChatEvent, error)"

    catalog_port:
      file: "internal/ports/catalog_port.go"
      interface: "CatalogPort"
      status: "implemented"
      methods:
        - "GetTenantBySlug(ctx, slug) (*Tenant, error)"
        - "GetCategories(ctx) ([]Category, error)"
        - "GetMasterProduct(ctx, id) (*MasterProduct, error)"
        - "ListProducts(ctx, tenantID, filter) ([]Product, int, error)"
        - "GetProduct(ctx, tenantID, productID) (*Product, error)"
      types:
        - "ProductFilter: CategoryID, Brand, MinPrice, MaxPrice, Search, Limit, Offset"

    state_port:
      file: "internal/ports/state_port.go"
      interface: "StatePort"
      status: "implemented"
      methods:
        - "CreateState(ctx, sessionID) (*SessionState, error)"
        - "GetState(ctx, sessionID) (*SessionState, error)"
        - "UpdateState(ctx, state) error"
        - "AddDelta(ctx, sessionID, delta) error"
        - "GetDeltas(ctx, sessionID) ([]Delta, error)"
        - "GetDeltasSince(ctx, sessionID, fromStep) ([]Delta, error)"

  adapters:
    anthropic:
      file: "internal/adapters/anthropic/anthropic_client.go"
      implements: "LLMPort"
      status: "implemented"
      method: "Chat(ctx, message) (string, error)"
      api: "POST https://api.anthropic.com/v1/messages"

    postgres:
      directory: "internal/adapters/postgres/"
      status: "implemented"
      files:
        - "postgres_client.go - Connection pool (pgxpool)"
        - "postgres_cache.go - CachePort implementation"
        - "postgres_events.go - EventPort implementation"
        - "migrations.go - Auto-migrations for chat tables"
        - "postgres_catalog.go - CatalogPort implementation with product merging"
        - "catalog_migrations.go - Catalog schema migrations"
        - "catalog_seed.go - Seed data (tenants, categories, products)"
        - "postgres_state.go - StatePort implementation with JSONB storage"
        - "state_migrations.go - State table migrations"
        - "postgres_state_test.go - State repository tests"

    json_store:
      file: "internal/adapters/json_store/json_product_store.go"
      implements: "SearchPort"
      status: "stub"

    memory:
      file: "internal/adapters/memory/memory_cache.go"
      implements: "CachePort"
      status: "stub (replaced by postgres)"

  tools:
    registry:
      file: "internal/tools/tool_registry.go"
      struct: "Registry"
      purpose: "Central registry for all tool executors"
      methods:
        - "NewRegistry(statePort, catalogPort) - creates registry with dependencies"
        - "Register(tool) - adds tool to registry"
        - "GetDefinitions() - returns all tool definitions for LLM"
        - "Execute(ctx, sessionID, toolCall) - runs tool by name"

    search_products:
      file: "internal/tools/tool_search_products.go"
      struct: "SearchProductsTool"
      implements: "ToolExecutor"
      purpose: "Search products and write to state"
      methods:
        - "Definition() - returns tool schema for LLM"
        - "Execute(ctx, sessionID, input) - searches products, updates state, returns 'ok'/'empty'"
      input_schema:
        query: "required - search query"
        category: "optional - category filter"
        brand: "optional - brand filter"
        min_price: "optional - minimum price"
        max_price: "optional - maximum price"
        limit: "optional - max results (default 10)"

  usecases:
    chat_send_message:
      file: "internal/usecases/chat_send_message.go"
      struct: "SendMessageUseCase"
      purpose: "Send message to LLM, save to DB, track events"
      status: "implemented"
      methods:
        - "Execute(ctx, req) (*SendMessageResponse, error)"
        - "WithSessionTTL(duration) *SendMessageUseCase"
      features:
        - "Session management with sliding TTL (10 min default)"
        - "Message persistence to PostgreSQL"
        - "Event tracking (chat_opened, message_sent, message_received)"
        - "Graceful handling when DB not configured"

    catalog_list_products:
      file: "internal/usecases/catalog_list_products.go"
      struct: "ListProductsUseCase"
      purpose: "List products for tenant with filtering"
      status: "implemented"
      methods:
        - "Execute(ctx, req) (*ListProductsResponse, error)"

    catalog_get_product:
      file: "internal/usecases/catalog_get_product.go"
      struct: "GetProductUseCase"
      purpose: "Get single product with master data merging"
      status: "implemented"
      methods:
        - "Execute(ctx, req) (*Product, error)"

    agent1_execute:
      file: "internal/usecases/agent1_execute.go"
      struct: "Agent1ExecuteUseCase"
      purpose: "Agent 1 Tool Caller - query → tool call → state update"
      status: "implemented"
      request: "{ SessionID string, Query string }"
      response: "{ Delta *Delta, Usage LLMUsage, LatencyMs int }"
      methods:
        - "Execute(ctx, req) (*Agent1ExecuteResponse, error)"
      flow:
        - "Get or create session state"
        - "Call LLM with tools (ChatWithTools)"
        - "Execute tool call via Registry"
        - "Create and save delta"
        - "Return delta with usage stats"

    agent2_execute:
      file: "internal/usecases/agent2_execute.go"
      struct: "Agent2ExecuteUseCase"
      purpose: "Agent 2 Template Builder - meta → LLM → template → state"
      status: "implemented"
      request: "{ SessionID string, LayoutHint string }"
      response: "{ Template *FormationTemplate, Usage LLMUsage, LatencyMs int }"
      methods:
        - "Execute(ctx, req) (*Agent2ExecuteResponse, error)"
      flow:
        - "Get current state (must exist after Agent 1)"
        - "Check if data exists (count > 0)"
        - "Build prompt with meta only (NOT raw data)"
        - "Call LLM with ChatWithUsage"
        - "Parse JSON template from response"
        - "Save template to state.Current.Template"
        - "Return template with usage stats"

    pipeline_execute:
      file: "internal/usecases/pipeline_execute.go"
      struct: "PipelineExecuteUseCase"
      purpose: "Full pipeline orchestrator: Agent 1 → Agent 2 → Formation"
      status: "implemented"
      request: "{ SessionID string, Query string }"
      response: "{ Formation *FormationWithData, Delta *Delta, Agent1Ms, Agent2Ms, TotalMs int }"
      methods:
        - "Execute(ctx, req) (*PipelineExecuteResponse, error)"
      flow:
        - "Step 1: Execute Agent 1 (Tool Caller)"
        - "Step 2: Execute Agent 2 (Template Builder)"
        - "Step 3: Apply template to data (ApplyTemplate)"
        - "Return FormationWithData with timing stats"

    template_apply:
      file: "internal/usecases/template_apply.go"
      purpose: "Apply FormationTemplate to products, produce FormationWithData"
      status: "implemented"
      functions:
        - "ApplyTemplate(template, products) (*FormationWithData, error)"
        - "applyWidgetTemplate(wt, product, index) (*Widget, error)"
        - "getFieldValue(product, fieldName) interface{}"
      field_mapping:
        - "id → ID"
        - "name → Name"
        - "description → Description"
        - "price → Price"
        - "currency → Currency"
        - "images/image_url → Images[0]"
        - "rating → Rating"
        - "brand → Brand"
        - "category → Category"
        - "stock → StockQuantity"

  handlers:
    chat:
      file: "internal/handlers/handler_chat.go"
      struct: "ChatHandler"
      endpoint: "POST /api/v1/chat"
      request: "{ sessionId?: string, tenantId?: string, message: string }"
      response: "{ sessionId: string, response: string, latencyMs: int }"
      status: "implemented"

    session:
      file: "internal/handlers/handler_session.go"
      struct: "SessionHandler"
      endpoint: "GET /api/v1/session/{id}"
      response: "{ id, status, messages[], startedAt, lastActivityAt }"
      status: "implemented"

    health:
      file: "internal/handlers/handler_health.go"
      endpoints:
        - "GET /health"
        - "GET /ready"

    catalog:
      file: "internal/handlers/handler_catalog.go"
      struct: "CatalogHandler"
      status: "implemented"
      endpoints:
        - "GET /api/v1/tenants/{slug}/products"
        - "GET /api/v1/tenants/{slug}/products/{id}"
      query_params: ["category", "brand", "minPrice", "maxPrice", "search", "limit", "offset"]

    middleware_tenant:
      file: "internal/handlers/middleware_tenant.go"
      struct: "TenantMiddleware"
      purpose: "Resolve tenant slug from URL, validate tenant exists"
      status: "implemented"

    response:
      file: "internal/handlers/response.go"
      purpose: "JSON response helper"
      functions: ["writeJSON(w, status, data)"]

  domain:
    atom_entity:
      file: "internal/domain/atom_entity.go"
      types: ["AtomType", "Atom"]

    widget_entity:
      file: "internal/domain/widget_entity.go"
      types: ["WidgetType", "Widget"]

    formation_entity:
      file: "internal/domain/formation_entity.go"
      types: ["FormationType", "Formation"]

    message_entity:
      file: "internal/domain/message_entity.go"
      types: ["MessageRole", "Message"]
      fields: ["ID", "SessionID", "Role", "Content", "Widgets", "Formation", "TokensUsed", "ModelUsed", "LatencyMs", "SentAt", "ReceivedAt", "Timestamp"]

    session_entity:
      file: "internal/domain/session_entity.go"
      types: ["SessionStatus", "Session"]
      fields: ["ID", "UserID", "TenantID", "Status", "Messages", "Metadata", "StartedAt", "EndedAt", "LastActivityAt", "CreatedAt", "UpdatedAt"]

    user_entity:
      file: "internal/domain/user_entity.go"
      types: ["ChatUser"]
      fields: ["ID", "ExternalID", "TenantID", "Fingerprint", "IPAddress", "UserAgent", "Metadata", "FirstSeenAt", "LastSeenAt", "CreatedAt"]

    event_entity:
      file: "internal/domain/event_entity.go"
      types: ["EventType", "ChatEvent"]
      event_types: ["chat_opened", "message_sent", "message_received", "chat_closed", "widget_clicked", "session_timeout"]

    product_entity:
      file: "internal/domain/product_entity.go"
      types: ["Product"]
      fields: ["ID", "TenantID", "MasterProductID", "Name", "Description", "Price", "PriceFormatted", "Currency", "Images", "Rating", "StockQuantity", "Brand", "Category", "Tags", "Attributes"]

    tenant_entity:
      file: "internal/domain/tenant_entity.go"
      types: ["TenantType", "Tenant"]
      tenant_types: ["brand", "retailer", "reseller"]
      fields: ["ID", "Slug", "Name", "Type", "Settings", "CreatedAt", "UpdatedAt"]

    category_entity:
      file: "internal/domain/category_entity.go"
      types: ["Category"]
      fields: ["ID", "Name", "Slug", "ParentID"]

    master_product_entity:
      file: "internal/domain/master_product_entity.go"
      types: ["MasterProduct"]
      fields: ["ID", "SKU", "Name", "Description", "Brand", "CategoryID", "Images", "Attributes", "OwnerTenantID", "CreatedAt", "UpdatedAt"]

    domain_errors:
      file: "internal/domain/domain_errors.go"
      errors: ["ErrSessionNotFound", "ErrProductNotFound", "ErrInvalidQuery", "ErrLLMUnavailable", "ErrTenantNotFound", "ErrCategoryNotFound"]

    tool_entity:
      file: "internal/domain/tool_entity.go"
      types: ["ToolDefinition", "ToolCall", "ToolResult", "LLMMessage", "LLMResponse", "LLMUsage"]
      purpose: "Types for LLM tool calling support"
      helpers:
        - "LLMUsage.CalculateCost() - calculates USD cost from token usage"
        - "LLMPricing - map of model pricing per million tokens"

    template_entity:
      file: "internal/domain/template_entity.go"
      types:
        - "AtomTemplate: { Type, Field, Style, Format, Size }"
        - "WidgetTemplate: { Size, Priority, Atoms []AtomTemplate }"
        - "GridConfig: { Rows, Cols }"
        - "FormationTemplate: { Mode, Grid, WidgetTemplate }"
        - "FormationWithData: { Mode, Grid, Widgets []Widget }"
      purpose: "Templates for Agent 2 and final formation output"

    state_entity:
      file: "internal/domain/state_entity.go"
      types: ["TriggerType", "ActionType", "Action", "ResultMeta", "Delta", "StateMeta", "StateData", "StateCurrent", "SessionState"]
      trigger_types: ["USER_QUERY", "WIDGET_ACTION", "SYSTEM"]
      action_types: ["SEARCH", "FILTER", "SORT", "LAYOUT", "ROLLBACK"]
      purpose: "Delta-based state for two-agent pipeline"

api_endpoints:
  chat:
    method: "POST"
    path: "/api/v1/chat"
    body: "{ sessionId?: string, tenantId?: string, message: string }"
    response: "{ sessionId: string, response: string, latencyMs: int }"

  session:
    method: "GET"
    path: "/api/v1/session/{id}"
    response: "{ id, status, messages[], startedAt, lastActivityAt }"

  catalog_list:
    method: "GET"
    path: "/api/v1/tenants/{slug}/products"
    query: "?category=&brand=&minPrice=&maxPrice=&search=&limit=&offset="
    response: "{ products: Product[], total: int }"

  catalog_get:
    method: "GET"
    path: "/api/v1/tenants/{slug}/products/{id}"
    response: "Product (merged with master)"

  health:
    method: "GET"
    path: "/health"
    response: "OK"

  ready:
    method: "GET"
    path: "/ready"
    response: "OK"

database:
  provider: "Neon PostgreSQL"
  schemas:
    public:
      tables:
        - "chat_users - User/visitor tracking"
        - "chat_sessions - Chat sessions with status and TTL"
        - "chat_messages - Message history with metadata"
        - "chat_events - Analytics events"
    catalog:
      tables:
        - "tenants - Multi-tenant support (brand, retailer, reseller)"
        - "categories - Product categories with tree structure"
        - "master_products - Canonical product definitions"
        - "products - Tenant-specific listings linked to masters"
  features:
    - "Auto-migrations on startup"
    - "Connection pooling (pgxpool)"
    - "SSL required for Neon"
    - "Graceful shutdown"
    - "Product merging (tenant + master data)"
    - "Seed data on first run"

prompts:
  agent1_system:
    file: "internal/prompts/prompt_analyze_query.go"
    const: "Agent1SystemPrompt"
    purpose: "System prompt for Agent 1 (Tool Caller)"
    rules:
      - "ALWAYS call a tool, never just text"
      - "No explanations or clarifying questions"
      - "Tool results are 'ok' or 'empty' only"
      - "Stop after getting tool result"

  agent2_system:
    file: "internal/prompts/prompt_compose_widgets.go"
    const: "Agent2SystemPrompt"
    purpose: "System prompt for Agent 2 (Template Builder)"
    rules:
      - "ONLY output valid JSON, no explanations"
      - "Use fields that exist in input"
      - "Choose widget size based on atom count"
      - "Choose mode based on count (1→single, 2-6→grid, 7+→carousel)"
    function: "BuildAgent2Prompt(meta StateMeta, layoutHint string) string"

patterns:
  naming:
    handlers: "handler_{name}.go"
    usecases: "{domain}_{action}.go"
    adapters: "{tech}_{purpose}.go"
    domain: "{entity}_entity.go"
    ports: "{name}_port.go"
    prompts: "prompt_{name}.go"
    tools: "tool_{name}.go"

  handler_pattern:
    - "Parse request body"
    - "Validate input"
    - "Call use case"
    - "Return JSON response"

  usecase_pattern:
    - "Struct with port dependencies"
    - "NewXxxUseCase() constructor"
    - "Execute(ctx, req) method"

run_commands:
  start: "cd project/backend && go run ./cmd/server/"
  build: "cd project/backend && go build -o server ./cmd/server/"
  test: "cd project/backend && go test ./..."

dependencies:
  - "github.com/joho/godotenv"
  - "github.com/rs/cors"
  - "github.com/jackc/pgx/v5"
  - "github.com/google/uuid"

env_vars:
  required:
    - "ANTHROPIC_API_KEY"
  optional:
    - "PORT (default: 8080)"
    - "ENVIRONMENT (default: development)"
    - "LLM_MODEL (default: claude-haiku-4-5-20251001)"
    - "LOG_LEVEL (default: info)"
    - "DATABASE_URL (PostgreSQL connection string)"

migration_status:
  description: "Hexagonal architecture with PostgreSQL persistence and multi-tenant catalog"
  completed:
    - "Migrate to cmd/server/main.go entry point"
    - "Implement LLMPort with Chat method"
    - "Implement Anthropic adapter"
    - "Implement SendMessageUseCase"
    - "Implement ChatHandler"
    - "Add PostgreSQL adapter with connection pooling"
    - "Implement CachePort for session/message persistence"
    - "Implement EventPort for analytics"
    - "Add session TTL (10 min sliding)"
    - "Add GET /api/v1/session/{id} endpoint"
    - "Implement multi-tenant product catalog"
    - "Add CatalogPort with product merging"
    - "Add catalog migrations and seed data"
    - "Implement ListProducts and GetProduct use cases"
    - "Add TenantMiddleware for slug resolution"
    - "Add catalog API endpoints"
    - "Add StatePort interface for session state"
    - "Implement PostgreSQL state adapter with JSONB"
    - "Add state migrations and tests"
    - "Add tool_entity with LLM tool calling types"
    - "Add tools layer with Registry and ToolExecutor interface"
    - "Implement search_products tool"
    - "Add ChatWithTools method to LLMPort"
    - "Implement Agent1ExecuteUseCase (Tool Caller)"
    - "Add Agent1SystemPrompt"
    - "Implement Agent2ExecuteUseCase (Template Builder)"
    - "Add Agent2SystemPrompt and BuildAgent2Prompt"
    - "Add template_entity with FormationTemplate, FormationWithData"
    - "Implement PipelineExecuteUseCase (orchestrator)"
    - "Add ApplyTemplate function for template → widgets"
    - "Add ChatWithUsage method to LLMPort"
  next_steps:
    - "Wire Pipeline to HTTP handler"
    - "Add Formation rendering endpoint"
    - "Add widget click event handling"

# CRITICAL: Gotchas by hexagonal layer
gotchas:
  # Domain layer - entities, types, errors
  domain:
    - "Price stored in kopecks (int), not rubles (float)"
    - "sessionID and tenantID must be valid UUID format"
    - "ErrSessionNotFound returned when state doesn't exist"

  # Ports layer - interface contracts
  ports:
    - "CatalogPort.ListProducts(tenantID) requires UUID, not slug"
    - "Use GetTenantBySlug(slug) first to get tenant UUID"
    - "StatePort.GetState returns ErrSessionNotFound if no state"

  # Adapters layer - external system specifics
  adapters:
    postgres:
      - "FK: chat_session_state.session_id → chat_sessions.id"
      - "FK: chat_session_deltas.session_id → chat_sessions.id"
      - "FK: catalog.products.tenant_id → catalog.tenants.id"
      - "ProductFilter conditions are AND-combined"
      - "Search uses ILIKE with % wildcards"
    anthropic:
      - "API version: 2023-06-01 (not 2024)"
      - "Pricing: Haiku $1/$5, Sonnet $3/$15 per 1M tokens"
      - "Response includes usage.input_tokens, usage.output_tokens"

  # Usecases layer - orchestration rules
  usecases:
    - "Create session (CachePort) before creating state (StatePort)"
    - "Tools return 'ok'/'empty', not raw data"
    - "Agent1 stops after first tool call, doesn't see result"
    - "Agent2 receives meta only, never raw product data"
    - "Agent2 expects state to exist (run Agent1 first)"
    - "Pipeline orchestrates Agent1 → Agent2 → ApplyTemplate"
    - "LLM may wrap JSON in markdown code blocks, use extractJSON()"

  # Tools layer - tool execution specifics
  tools:
    - "If brand specified, don't use query as search (AND conflict)"
    - "Tool writes to state, returns only status string"
    - "Must resolve tenant slug → UUID before search"
