# Glossary

Глоссарий Keepstar. Что есть что, зачем, как связано.
Единственный источник правды по терминологии и архитектурным решениям.

---

## Продукт

**Keepstar** — встраиваемый AI-чат-виджет для e-commerce. Один `<script>` тег на сайте клиента даёт AI-ассистента, который отвечает не текстом, а интерактивными виджетами: карточки товаров, галереи, сравнения, произвольные компоновки.

**Ключевой принцип: Backend-First.** Фронтенд = тупая рендерилка. Вся логика, LLM, компоновка, state — на бэкенде. Фронт получает готовый JSON и рисует.

---

## Иерархия: Atom → Widget → Formation

Три уровня вложенности. Каждый уровень — отдельная ответственность.

```
Formation (экран)
│   Как виджеты расположены на экране
│   grid 3×2 | carousel | list | single | circle | scatter
│
├── Widget (виджет)
│   │   Контейнер из атомов = одна визуальная единица
│   │   Карточка товара, строка списка, блок сравнения
│   │
│   ├── Atom: Image   (фото товара)
│   ├── Atom: Text    (название)
│   ├── Atom: Number  (цена)
│   └── Atom: Number  (рейтинг)
│
├── Widget ...
└── Widget ...
```

---

## Atom (Атом)

**Что:** Неделимая единица информации. Самый маленький кирпичик.

**Зачем:** Гибкость. Агент оперирует атомами как конструктором — собирает из них что угодно. А фронт знает как отрендерить каждый тип.

**6 базовых типов (и только 6):**

| Тип | Описание | Примеры значений |
|-----|----------|------------------|
| `text` | Текст | "Nike Air Max 90", "В наличии" |
| `number` | Число | 12990, 4.7, 85% |
| `image` | Изображение | URL, base64 |
| `icon` | Иконка | emoji, SVG, имя иконки |
| `video` | Видео | URL |
| `audio` | Аудио | URL |

**Subtype** — уточнение формата данных внутри типа:
- text: string, date, url, email, phone
- number: int, float, currency, percent, rating
- image: url, base64

**Display** — стиль визуализации. Это НЕ тип атома, это чисто внешний вид:
- Текстовые: `h1`, `h2`, `h3`, `body`, `caption`, `badge`, `tag`
- Числовые: `price`, `price-lg`, `rating`, `rating-compact`
- Картинки: `image-cover`, `thumbnail`, `avatar`, `gallery`
- Кнопки: `button-primary`, `button-secondary`, `button-outline`

**Ключевой инсайт:** Агент видит не сами данные, а мета-информацию — какие поля существуют (name, price, rating, images) и сколько товаров. Он выбирает какие поля показать и с каким display. Бэкенд подставляет реальные значения. Это экономит токены, ускоряет ответ и снижает шанс ошибки.

**Slot** — позиция атома в виджете (куда вставить):

| Слот | Назначение |
|------|------------|
| `hero` | Главное изображение / карусель |
| `badge` | Бейдж-оверлей |
| `title` | Заголовок |
| `primary` | Ключевые атрибуты (бренд, рейтинг) |
| `price` | Цена |
| `secondary` | Второстепенные атрибуты (описание) |
| `gallery` | Полная галерея |
| `stock` | Наличие |
| `description` | Развёрнутое описание |
| `tags` | Теги-чипсы |
| `specs` | Таблица характеристик |

---

## Widget (Виджет)

**Что:** Контейнер из атомов. Одна визуальная единица на экране — карточка товара, строка списка, блок детализации.

**Зачем:** Атомы сами по себе бессмысленны — их нужно группировать. Виджет = "собранная карточка" с определённым размером и приоритетом.

**Свойства:**
- `atoms[]` — набор атомов с данными
- `size` — ограничение размера (tiny/small/medium/large)
- `entityRef` — ссылка на сущность (product/service + ID) для навигации (клик → expand)
- `priority` — порядок отображения

**Size constraints:**

| Size | Ширина | Max атомов |
|------|--------|------------|
| tiny | 80–110px | 2 |
| small | 160–220px | 3 |
| medium | 280–350px | 5 |
| large | 384–460px | 10 |

**Важно:** Виджет — это результат применения пресета (или фристайла) к данным. Агент НЕ создаёт виджеты напрямую. Агент создаёт пресет или шаблон → бэкенд генерирует виджеты.

---

## Preset (Пресет)

**Что:** Гибкий трафарет для виджета. Базовая конфигурация слотов и атомов, которую можно модифицировать по запросу пользователя: добавить поля, убрать поля, поменять местами, изменить размеры и display. Пресет — это отправная точка, не жёсткая рамка.

**Отличие от Template:** Template (шаблон) — жёсткая структура, зафиксированная один раз. Пресет — живой, его можно подстроить под конкретный запрос.

**Зачем:** Агент выбирает пресет по имени (одно слово) → опционально модифицирует поля → бэкенд раскатывает на все N товаров. Быстро, дёшево, предсказуемо. При этом гибко — пользователь может сказать "убери рейтинг, добавь описание" и агент перестроит пресет.

**Структура пресета:**
```
Preset {
  name:       "product_grid"
  entityType: product | service
  fields: [                        ← управляемые "ячейки" пресета
    {name: "images",  slot: hero,    display: image-cover}
    {name: "name",    slot: title,   display: h2}
    {name: "brand",   slot: primary, display: tag}
    {name: "price",   slot: price,   display: price}
    {name: "rating",  slot: primary, display: rating-compact}
  ]
  defaultSize: medium
}
```

**Fields (ячейки) — ключ к гибкости.** Каждый field = одна ячейка в пресете, привязанная к слоту с конкретным display. Агент может модифицировать пресет: убрать field, добавить новый, сменить display, переназначить слот. На основе набора ячеек можно понять какие пресеты нужно собрать и как их комбинировать.

**Как применяется:**
1. Agent2 говорит: "используй product_grid"
2. Бэкенд берёт пресет, берёт данные из стейта (6 товаров)
3. Для каждого товара: проходит по fields[], подставляет реальные значения → получается Widget с атомами
4. Все 6 виджетов собираются в Formation

**Текущие пресеты (7 штук):**

| Пресет | Для чего | Size |
|--------|----------|------|
| `product_grid` | Сетка товаров | medium |
| `product_card` | Одна карточка крупно | large |
| `product_compact` | Компактный список | small |
| `product_detail` | Полная детализация | large |
| `service_card` | Сетка услуг | medium |
| `service_list` | Компактный список услуг | small |
| `service_detail` | Полная детализация услуги | large |

**Известная проблема:** Пресет сейчас содержит `defaultMode` (grid/list/single) — это смешивает уровень пресета и уровень формации. Mode — свойство формации, не пресета. Пресет не должен знать в каком layout он будет показан.

---

## Formation (Формация)

**Что:** Расположение виджетов на экране. Layout-уровень.

**Зачем:** Одни и те же виджеты можно показать сеткой 3×2, каруселью, списком, по кругу. Формация — это КАК показать, а не ЧТО показать.

**Типы формаций (реализованные):**

| Тип | Описание | Когда |
|-----|----------|-------|
| `grid` | Сетка N×M | Несколько товаров |
| `list` | Вертикальный список | Компактное отображение |
| `carousel` | Горизонтальный скролл | Рекомендации, похожие |
| `single` | Один виджет, крупно | Детализация, одна карточка |

**Типы формаций (задуманные, не реализованы):**

| Тип | Описание | Когда |
|-----|----------|-------|
| `circle` | По окружности | Сравнение, ранжирование |
| `scatter` | Свободное расположение | Креативные запросы |
| `focus` | Один большой + мелкие вокруг | Главный + альтернативы |
| `comparison` | Таблица сравнения | "Сравни эти два" |

**Структура FormationWithData (финальный JSON для фронта):**
```
{
  mode:    "grid",
  grid:    {rows: 2, cols: 3},
  widgets: [Widget, Widget, ...],
  config:  RenderConfig          // как Agent2 это собрал (для контекста следующего turn)
}
```

---

## Режимы работы Agent2

Agent2 отвечает за визуальное представление. У него два режима (не три — Template = простой Freestyle).

### Режим 1: Preset

Агент выбирает готовый пресет по имени, опционально модифицирует его ячейки (fields). Бэкенд раскатывает результат на все товары.

```
Agent2: "render_product_preset({preset: product_grid})"
→ Бэкенд: берёт пресет → раскатывает на 6 товаров → 6 виджетов → формация

Agent2: "render_product_preset({preset: product_grid, fields: [убрать rating, добавить description]})"
→ Бэкенд: модифицирует пресет → раскатывает → формация
```

**Когда:** Стандартные и модифицированные сценарии. "Покажи кроссовки" → product_grid. "Покажи без рейтинга, с описанием" → product_grid + field overrides. "Покажи подробнее" → product_detail.

**Плюсы:** Минимум токенов (имя + опциональные overrides), предсказуемый результат, быстро, при этом гибко.

### Режим 2: Freestyle

Агент создаёт визуализацию с нуля. Нет готового трафарета.

**Спектр freestyle:**

| Простой freestyle | Полный freestyle |
|-------------------|------------------|
| Кастомная маска, одинаковая для всех товаров | Каждый виджет уникален |
| Бэкенд раскатывает на N штук | Агент специфицирует каждый |
| "Покажи только фото и цену крупно" | "Макбуки по кругу от слабых к сильным" |
| Нужны: слоты + display overrides | Нужны: позиции, размеры, знание экрана |

**Когда:** Ни один пресет не подходит. Пользователь просит нестандартное отображение.

**Текущее состояние:** На холде. Freestyle почти не работает. Реализация — 5 захардкоженных style alias + slot→display overrides. По сути "preset с перезаписью стилей". До настоящего фристайла далеко.

**Что нужно для полного freestyle:**
- Информация о размере экрана пользователя
- Возможность задавать произвольные формации (circle, scatter, позиции x/y)
- Возможность создавать разные виджеты для разных товаров
- Это дорого по токенам и сложно в реализации

---

## Pipeline (Пайплайн)

Главный flow обработки запроса пользователя.

```
User Query
    │
    ▼
Agent1 (Data)
    │  Понимает ЧТО искать
    │  Вызывает catalog_search
    │  Пишет товары в State.Data
    │
    ▼
Agent2 (UI)
    │  Решает КАК показать
    │  Вызывает render_preset или freestyle
    │  Пишет формацию в State.Template
    │
    ▼
Formation JSON → Frontend рендерит
```

### Agent1 — Data Retrieval

**Задача:** Из свободного текста понять что искать и вызвать нужный tool.

**Что видит:** Запрос пользователя + CatalogDigest (категории, бренды, ценовые диапазоны тенанта). **Начиная со второго запроса** — также мету текущего стейта: что уже найдено, сколько товаров, какие поля. Это позволяет Agent1 понять: нужно ли искать дальше или данные уже есть и можно сразу передать управление Agent2 для визуального изменения.

**Что делает:** Вызывает `catalog_search` с параметрами:
- `vector_query` — семантический поиск на языке пользователя
- `filters` — структурированные фильтры (brand, category, price range) на английском
- `entity_type` — product / service / all

**Ключевой инсайт:** Agent1 НЕ видит результаты поиска. Tool пишет данные в стейт и возвращает агенту только "ok: found 6 products" или "empty: 0 results". Это экономит токены.

**Правило:** Если пользователь просит изменить СТИЛЬ отображения (не новые данные) — Agent1 не вызывает tool. Передаёт управление Agent2.

### Agent2 — UI Composition

**Задача:** Решить КАК отобразить данные из стейта.

**Что видит:** Мету: count, fields[], текущий RenderConfig (что сейчас на экране), запрос пользователя, info о том что изменилось (data_change).

**Что НЕ видит:** Сырые данные (товары, цены, описания). Только структуру и количества.

**Что делает:** Вызывает render_*_preset или freestyle → tool строит формацию из данных стейта → пишет в State.Template.

**ToolChoice = "any"** — Agent2 ОБЯЗАН вызвать tool. Не может ответить текстом.

### Agent0 — Router (НЕ реализован, на холде)

**Задача:** Быстрая классификация intent перед тяжёлыми агентами. ~200 токенов.

**Intents (задуманные):**

| Intent | Pipeline |
|--------|----------|
| `search` | Agent1 → Agent2 (стандартный) |
| `clarify` | "А что по второму?" → нужна история + конкретный товар |
| `compare` | "Сравни первый и третий" → таблица сравнения |
| `filter` | "Дешевле 50000" → фильтрация без LLM |
| `support` | "Забыл пароль" → FAQ/RAG |
| `viz` | "Покажи таблицей" → только Agent2 |

**Зачем нужен:** Без роутера каждый агент должен понимать все кейсы. С роутером — агент получает только релевантный контекст. Экономия токенов и скорости.

---

## State System (Система стейта)

Центральная часть архитектуры. Через неё всё протекает: агенты пишут, фронт читает, навигация манипулирует. Состоит из трёх слоёв.

### Слой 1: State — текущий снапшот

**Что:** Материализованное текущее состояние сессии. "Что есть прямо сейчас." Одна строка в таблице `chat_session_state`.

**Зачем:** Быстрый доступ к текущему состоянию без перечитывания истории. Агенты и фронт читают стейт, а не дельты.

**4 зоны:**

```
SessionState
│
├── ЗОНА 1: DATA
│   ├── current_data     {products[], services[]}
│   └── current_meta     {count, productCount, serviceCount, fields[], aliases{}}
│   Кто пишет: Agent1 (catalog_search)
│
├── ЗОНА 2: TEMPLATE
│   └── current_template {"formation": {mode, grid, widgets[], config}}
│   Кто пишет: Agent2 (render_preset / freestyle)
│
├── ЗОНА 3: VIEW
│   ├── view_mode        grid | detail | list
│   ├── view_focused     {type, id} или null
│   └── view_stack       [{mode, focused, refs[], step, createdAt}, ...]
│   Кто пишет: Expand/Back usecases
│
└── ЗОНА 4: CONVERSATION
    └── conversation_history [{role, content}, ...]
    Кто пишет: Agent1 (после tool execution)
    Append-only, без дельт — чисто для LLM prompt caching
```

### Слой 2: Deltas — история обновлений стейта

**Что:** Append-only журнал всех изменений стейта. Каждое обновление зоны создаёт запись в `chat_session_deltas`. По сути — лог "как стейт пришёл к текущему состоянию".

**Зачем:**
- Откат — восстановить стейт на любом шаге: `State(N) = apply(Delta[0..N])`
- Аудит — видно кто что когда записал
- Turn tracking — `turn_id` группирует дельты по ходам пользователя

**Структура одной дельты:**
```
Delta {
  step        int         // порядковый номер (auto-increment per session)
  turn_id     string      // группирует дельты одного хода
  trigger     USER_QUERY | WIDGET_ACTION | SYSTEM
  source      user | llm | system
  actor_id    agent1 | agent2 | user_expand | user_back
  delta_type  add | remove | update | push | pop | rollback
  path        data.products | template | view    // какая зона затронута
  action      {type, tool, params}               // что произошло
  result      {count, fields[]}                  // мета результата
  template    JSONB (optional snapshot)
  created_at  timestamp
}
```

**Кто создаёт:**

| Актор | Зона | DeltaType | Когда |
|-------|------|-----------|-------|
| agent1 (catalog_search) | data.products | add | Поиск товаров/услуг |
| agent2 (render_*_preset) | template | update | Выбор пресета |
| agent2 (freestyle) | template | update | Freestyle рендеринг |
| user_expand | view | push | Клик → детализация |
| user_expand | template | update | Формация детализации |
| user_back | view | pop | Клик назад |
| user_back | template | update | Восстановление формации |

**Пример сессии (8 дельт = 4 хода):**
```
Step 1  turn-abc  agent1       add     data.products  → найдено 6 товаров
Step 2  turn-abc  agent2       update  template       → product_grid
Step 3  turn-def  user_expand  push    view           → клик на товар #3
Step 4  turn-def  user_expand  update  template       → detail formation
Step 5  turn-ghi  user_back    pop     view           → назад
Step 6  turn-ghi  user_back    update  template       → grid formation
Step 7  turn-jkl  agent1       add     data.products  → новый поиск, 3 товара
Step 8  turn-jkl  agent2       update  template       → product_grid
```

### Слой 3: Что есть ТОЛЬКО в дельтах (не в стейте)

Стейт хранит "что есть сейчас". Дельты хранят "как мы сюда пришли". Некоторая информация существует **только** в дельтах:

- **История поисков** — какие запросы, с какими фильтрами (`action.params`)
- **Хронология** — в каком порядке что происходило (`step` + `created_at`)
- **Авторство** — кто именно сделал изменение (`source` + `actor_id`)
- **Turn группировка** — какие действия относятся к одному ходу (`turn_id`)

### Как стейт и дельты связаны

```
Zone-write = обновить зону стейта + записать дельту — атомарно.

UpdateData(data, meta, deltaInfo)    →  current_data = data   +  дельта в журнал
UpdateTemplate(template, deltaInfo)  →  current_template = ..  +  дельта в журнал
UpdateView(view, stack, deltaInfo)   →  view_mode = ..         +  дельта в журнал
AppendConversation(messages)         →  conversation_history   +  БЕЗ дельты
```

**UpdateState()** — bulk перезапись ВСЕГО стейта, без дельты. Только для rollback и debug. В штатном flow не используется.

### Известные проблемы (не блокер для MVP)

**Двойная роль дельт.** Дельты одновременно выполняют роль event log (что произошло) и state journal (что изменилось). Из-за этого:
- Навигация (push/pop) дублируется между дельтами и `view_stack` в стейте
- `result.count/fields` в дельте дублирует `current_meta` в стейте
- Для навигации по ходам (turns) на фронте придётся фильтровать дельты по turn_id

При масштабировании может потребоваться разделение на чистый event log + turn history. **Рефакторить позже.**

---

## Navigation (Навигация)

### Decision Tree (Дерево решений)

Каждый ответ бэкенда = **узел дерева**. У узла — предсобранные потомки (один уровень вперёд). Детерминированные переходы (клик, back) = мгновенные (из кэша). Чат = новая ветка (round-trip, но ожидаемо).

```
[Pipeline response] = Node A (Grid 6 товаров)
│   adjacentFormations: Detail 1..6 [PRE-BUILT]
│   formationStack: [...previous formations]
│
├── Click карточка 3 → instant (из adjacent)
├── Back → instant (из стека)
└── Chat "другое" → round-trip → Node B (новая ветка)
```

Три уровня стоимости перехода:

| Действие | Стоимость | Механизм |
|----------|-----------|----------|
| Клик / Back | ~0ms | Formation stack + adjacentFormations (кэш на FE) |
| Чат (данные меняются) | Round-trip | Pipeline → Agent1 → Agent2 → Formation |
| Чат (отображение меняется) | Round-trip (быстрее) | Pipeline → Agent2 → Formation |

### Expand (раскрытие)

Клик на виджет → переход к детализации.

**Реализация (instant navigation):**
1. Бэкенд в pipeline response предгенерирует `adjacentFormations` — detail-формации для каждого entity в текущей grid/list
2. Expand на фронте: lookup `adjacentFormations["entityType:entityId"]` → мгновенный рендер (<16ms)
3. Push текущей формации в formation stack (для back)
4. Fire-and-forget POST `/navigation/expand?sync=true` для синхронизации backend state
5. Fallback: если entity нет в adjacent (edge case) — обычный blocking POST

### Back (назад)

Возврат к предыдущему виду.

**Реализация (instant navigation):**
1. Фронт хранит **formation stack** — стек предыдущих формаций (useFormationStack hook)
2. Back = `stack.pop()` → рендер предыдущей формации (<16ms)
3. Fire-and-forget POST `/navigation/back?sync=true`
4. Стек персистируется в localStorage (sessionCache) — переживает F5

### Background Sync

Fire-and-forget вызовы для синхронизации backend state после instant-переходов. URL содержит `?sync=true` — backend выполняет state update (ViewStack push/pop, deltas), но возвращает `{"ok": true}` без formation (экономия сериализации). Если sync-вызов упал — self-healing: следующий pipeline call пересобирает state.

### Кастомная навигация через чат

Пользователь пишет "покажи подробнее первый, но только характеристики и цену". Это НЕ мгновенный переход — это запрос к Agent2 на кастомный пресет/фристайл. Round-trip к бэкенду неизбежен.

---

## Catalog (Каталог)

### Структура данных

```
Tenant (клиент)
├── MasterProducts (общие товары)
│   └── Products (overlay клиента: своя цена, наличие, описание)
│       └── Stock (отдельная таблица: tenant_id + product_id → quantity)
│
├── MasterServices (общие услуги)
│   └── Services (overlay клиента)
│
└── CatalogDigest (предвычисленная мета-схема каталога)
    Категории, бренды, ценовые диапазоны, популярные фильтры
    Используется Agent1 для точных фильтров
```

### Hybrid Search

`catalog_search` — мета-tool, объединяющий:
1. **Keyword search** — SQL ILIKE по имени, категории, бренду
2. **Vector search** — pgvector cosine similarity по embeddings
3. **RRF merge** — Reciprocal Rank Fusion для объединения результатов (keyword weight 1.5×, vector 1.0×)

---

## Widget (Виджет-оболочка)

Встраиваемый чат-виджет на сайте клиента.

**Как работает:**
```html
<script src="https://keepstar.one/widget.js" data-tenant="nike"></script>
```

1. Скрипт находит свой `<script>` тег, читает `data-tenant`
2. Создаёт `<div>` с Shadow DOM (полная CSS-изоляция)
3. Инжектит все стили внутрь Shadow DOM
4. Монтирует React приложение внутрь Shadow DOM
5. Показывает кнопку чата (60px круг, bottom-right)
6. По клику: открывает overlay с чатом + зоной виджетов

**Tenant context:** `X-Tenant-Slug` header во всех API запросах.

**Build:** Vite → единый `widget.js` (IIFE, ~72KB gzip). Custom `shadowDomCss()` plugin инлайнит все CSS через `?inline`.

---

## Мультитенантность

Один инстанс Keepstar обслуживает множество клиентов (тенантов). Каждый тенант:
- Имеет свой каталог (товары + услуги)
- Свой виджет (один JS, разный `data-tenant`)
- Изолированные данные в БД (`tenant_id` на всех таблицах)
- Общий master catalog (shared knowledge base для лучшего vector search)

---

## Ключевые архитектурные решения

### Почему агент работает с мета, а не с данными
Если в каталоге 400 товаров по 40 атрибутов — это 16000 значений. Передать агенту = дорого, медленно, шанс ошибки. Вместо этого агент получает мету (count: 400, fields: [name, price, rating, ...]) и один "эталонный" товар. Генерирует один шаблон → бэкенд раскатывает на все 400.

### Почему два агента, а не один
- Agent1 (data) и Agent2 (UI) — разные задачи, разные промпты, разные tools
- Разделение снижает сложность каждого промпта
- Agent2 не видит сырые данные → меньше токенов
- Можно запускать Agent2 без Agent1 (чистый визуальный запрос)

### Почему zone-write, а не UpdateState
- UpdateState перезаписывает ВЕСЬ стейт — race condition если два процесса пишут одновременно
- Zone-write обновляет только свою зону + создаёт дельту атомарно
- Дельты дают историю и возможность отката

### Почему formation ≠ preset
- Preset = ЧТО показать внутри каждого виджета (слоты + атомы)
- Formation = КАК расположить виджеты на экране (grid, list, carousel)
- Один пресет может отображаться в разных формациях
- Одна формация может содержать виджеты из разных пресетов

---

*Последнее обновление: 2026-02-12*
